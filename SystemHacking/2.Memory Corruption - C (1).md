# Memory Corruption  

# Stack Buffer Overflow  
세계 최초의 웜; 모리스 웜도 스택 버퍼 오버플로우 공격을 통해 전파됨  

> **스택 오버플로우 vs 스택 버퍼 오버플로우**  
> 스택 영역은 실행 중에 크기가 동적으로 확장될 수 있음  
> 그러나 한정된 크기의 메모리 안에서 스택이 무한히 확장될 수는 없음  
> 스택 오버플로우(Stack Overflow): 스택 영역이 너무 많이 확장돼서 발생하는 버그  
> 스택 버퍼 오버플로우: 스택에 위치한 버퍼에 버퍼의 크기보다 많은 데이터가 입력되어 발생하는 버그  

## 버퍼 오버플로우  
스택의 버퍼에서 발생하는 오버플로우  

### 버퍼  
버퍼(Buffer): 일상에서는 '완충 장치', 컴퓨터 과학에서는 '데이터가 목적지로 이동되기 전에 보관되는 임시 저장소'  
데이터의 처리 속도가 다른 두 장치가 있을 때, 이 둘 사이에 오가는 데이터를 임시로 저장해 두는 것은 일종의 완충 작용을 함  
ex) 키보드에서 데이터가 입력되는 속도 > 데이터를 처리하는 속도가 느린 프로그램 -> 별도의 장치 없으면 키보드 입력 중에 데이터 모두 유실됨  
수신 측과 송신 측 사이에 버퍼라는 임시 저장소 두고, 이를 통해 간접적으로 데이터를 전달하게 함  
송신 측은 버퍼로 데이터 전송, 수식 측은 버퍼에서 데이터를 꺼내 사용  
버퍼가 가득 찰 때까지는 유실되는 데이터 없이 통신 가능  
nowadays; 데이터가 저장될 수 있는 모든 단위를 버퍼라고 부르기도 함  
스택 버퍼: 스택에 있는 지역 변수  
힙 버퍼: 힙에 할당된 메모리 영역  

> **버퍼링** : 송신 측의 전송 속도가 느려서 수신 측의 버퍼가 채워질 때까지 대기하는 것  

### 버퍼 오버 플로우  
Buffer Overflow  
버퍼가 넘치는 것  
버퍼는 제각기 크기를 가지고 있음  
일반적으로 버퍼는 메모리 상에 연속되어 할당되어 있으므로, 어떤 버퍼에서 오버플로우가 발생하면 뒤에 있는 버퍼들의 값이 조작될 위험 있음  
-> 버퍼 오버플로우는 지정된 버퍼의 크기보다 많은 데이터가 입력되어 발생, 모든 메모리 영역에서 발생 가능  

C언어에서 버퍼 -> 지정된 크기의 메모리 공간  
BOF -> 버퍼가 허용될 수 있는 양의 데이터보다 더 많은 값이 저장되어 버퍼가 넘치는 취약점  
발생하는 위치에 따라 Stack BOF, Heap BOF  

BOF는 인접한 메모리를 오염시키는 취약점이라 어떤 메모리를 오염시킬 수 있느냐에 따라 공격 방법이 달라지기 때문  
BOF는 프로그램의 undefined behavior(정의되어있지 않은 동작: 런타임 중에 어떤 현상이 발생할지 예측할 수 없다는 뜻)을 이끌어냄  
BOF는 프로그래머가 버퍼의 길이에 대한 가정을 올바르게 하지 않아 발생한다. 이는 보통 길이제한이 없는 API 함수들을 사용하거나 버퍼의 크기보다 입력받는 데이터의 길이가 더 크게 될 때 자주 일어나는 실수다.

#### 중요 데이터 변조  
버퍼 오버플로우가 발생하는 버퍼 뒤에 중요한 데이터가 있다면, 해당 데이터가 변조됨으로써 문제 발생  

#### 데이터 유출  
C언어에서 정상적인 문자열은 널바이트로 종결됨  
표준 문자열 출력 함수들은 널바이트를 문자열의 끝으로 인식  
ex) 어떤 버퍼에 오버플로우 발생시켜서 다른 버퍼와의 사이에 있는 널바이트를 모두 제거하면, 해당 버퍼를 출력시켜서 다른 버퍼의 데이터를 읽을 수 있음  

획득한 데이터는 각종 보호기법을 우회하는데 사용될 수 있음 or 해당 데이터 자체가 중요한 정보일 수도  

> **C/C++의 문자열 종결자(Terminator)와 표준 문자열 함수들의 취약성**  
> C계열 언어에서는 널바이트("\x00")로 종료되는 데이터 배열을 문자열로 취급  
> 문자열을 다루는 대부분의 표준 함수는 널 바이트를 만날 때까지 연산 진행  
> 널 바이트가 없을 경우, 널 바이트를 찾을 때까지 배열 참조, 코드 작성할 때 정의한 배열의 크기를 넘어서도 계속해서 인덱스를 증가시킴  
> => 참조하려는 인덱스 값이 배열의 크기보다 커지는 현상: **Index Out-Of-Bound(OOB)**; OOB 취약점  
> => 개발자는 입력의 길이 제한하는 문자열 함수 사용 & 문자열을 사용할 때는 반드시 해당 문자열이 널 바이트로 종결되는지 확인  

#### 실행 흐름 조작  
스택 버퍼 오버플로우로 함수 호출 후 원래 실행흐름으로 돌아가기 위한 반환 주소 조작 -> 프로세스의 실행 흐름 바꾸기  

**Stack BOF**  
지역변수가 할당되는 스택메모리에서 Overflow 발생  
프로그래머가 길이에 대한 검증을 수행하지 못해서 발생한다. 입력받을 때 길이 제한이 없는 함수를 사용하면 이 공격에 취약해진다. 입력받은 데이터가 버퍼에 저장되기까지의 흐름을 따라가 버퍼에 크기를 넘는 양을 저장할 수 있는지 가능성을 검토해야한다.  

<--A--><--B-->  
ㅁㅁㅁㅁㅁㅁㅁㅁ  
만약 데이터영역 B에 나중에 호출될 함수포인터를 저장하고 있다면, 이 값을 "AAAAAAAA"와 같은 데이터로 덮었을 때 Segmentation Fault(접근권한이 없는 메모리 영역을 읽거나 쓰려고할 때 발생하는 예외)를 발생시킬 것입니다.  
공격자는 어딘가에 기계어 코드를 삽입한 후 함수포인터를 공격자의 코드의 주소로 덮어 코드 실행 가능  

```
[예제문제 풀면서 배운것]

sfp: saved frame pointer  
이전 함수의 EBP 주소를 저장하고 있는 공간  

sprintf(배열, 서식, 값 1, ...) : 배열에 서식 저장  
ex. sprintf(buf, "Your Input is : %\n", buf);  
만약 buf에 31바이트를 꽉 채운다면 "Your Input is:" 문자열이 앞에 붙어 총 길이가 32바이트를 넘게 됩니다.  

scanf 함수의 포맷 스트링 중 하나인 %s는 문자열 입력 받을 때 입력의 길이 제한 X -> 절대로 사용하면 X  
정확히 n개의 문자만 입력받는 "%[n]s"의 형태로 사용해야 함  
+) C/C++ 표준함수 중 버퍼를 다루면서 길이를 입력하지 않는 함수들은 대부분 위험  
-> strcpy, strcat, sprintf  
=> 버퍼의 크기를 같이 입력하는 strncpy, strncat, snprintf, fgets, memcpy 등을 사용하는 것이 바람직  
=> 취약점 찾을 때 취약한 함수들이 사용되지 않았는지 유의하기  

Segmentation fault(core dumped): 프로그램이 잘못된 메모리 주소에 접근했다는 의미, 프로그램에 버그가 발생했다는 신호 + 코어 파일을 생성 -> 프로그램이 비정상 종료됐을 때, 디버깅을 돕기 위해 운영체제가 생성해주는 것  
리눅스는 기본적으로 코어 파일의 크기에 제한을 두고 있음. 바이너리가 세그먼테이션 폴트를 발생시키고도 코어파일을 생성하지 않았다면, 생성해야할 코어파일의 크기가 이를 초과했기 때문  
gdb에는 코어 파일 분석하는 기능 있음 -> gdb -c core  


```

프로그래머가 동적으로 메모리를 관리할 수 있는 힙에서도 발생 가능하다. 힙 영역은 스택 영역과 사용 목적이 다르기 때문에 스택오버플로우와는 다른 방법으로 익스플로잇 해야한다. -> Linux Exploitation&Mitigation 강의에서 다룬다. (+힙은 먼저 선언한게 메모리의 low 주소로 들어간다.)  


## Out-of-boundary  
버퍼의 길이를 벗어나는 인덱스에 접근할 때 발생하는 취약점  

```
[예제문제 풀면서 배운것]

high 주소  
|int idx|  
|int buf[10]|  
|int win|  
buf배열에서 음수 인덱스로 win에 접근 가능, win도 int이므로 win은 buf[-1]로 접근 가능  

idx % 10했을 때 buf[10] 접근은 안전할까? NO  
양의 정수를 10으로 나눈 나머지로 가능한 값은 0에서 9까지기 때문에 이는 얼핏보면 안전해보인다.  
But, C언어에서는 피연산자가 음수라면 나머지 연산의 결과도 음수가 될 수 있다. 따라서 이 경우 idx의 값의 범위가 -9 ~ 9이므로 나머지가 음수가 되게 한다면 OOB 발생이 가능하다.  

high 주소  
|int idx|  
|int buf[10]|  
|int dummy[7]|  
|int win| -> buf[-8]로 접근 가능  
C언어에서 int형으로 표현 가능한 정수의 범위는 -pow(2,31) ~ pow(2,31)-1 이다.  
int형은 32비트이기 때문에 총 pow(2,32)개의 수를 표현할 수 있다. int형은 0을 포함하기 때문에 포현할 수 있는 음의 정수의 갯수와 양의 정수의 갯수는 다르다.  
int형에서 -pow(2,31)은 표현 가능하지만 pow(2,31)은 표현 가능하지 않다.  
Therefore, pow(2,31)은 표현 가능한 최대 정수보다 하나 더 크기 때문에 이는 -pow(2,31)과 같은 값이 된다.  
=> idx에 -pow(2,31)을 넣었을 때 절댓값을 구하는 연산을 수행해도 -2**31이 그대로 저장된다. ==> OOB 발생  
이를 근본적으로 막기 위해서는 idx를 int형이 아닌 unsigned int형으로 선언하거나, 인덱스를 입력받은 후에 if(idx < 0 | idx >= 10)과 같은 경계 검사 구문을 추가해야 한다.  
```

## Off-bye-one  
경계 검사에서 하나의 오차가 있을 때 발생한다.  
이는 버퍼의 경계 계산 혹은 반복문의 횟수 계산 시 < 대신 <= 을 쓰거나, 0부터 시작하는 인덱스를 고려하지 못할 때 발생한다.

