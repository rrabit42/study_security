## 버퍼오버플로우  
C언어에서 버퍼 -> 지정된 크기의 메모리 공간  
BOF -> 버퍼가 허용될 수 있는 양의 데이터보다 더 많은 값이 저장되어 버퍼가 넘치는 취약점  
발생하는 위치에 따라 Stack BOF, Heap BOF  

BOF는 인접한 메모리를 오염시키는 취약점이라 어떤 메모리를 오염시킬 수 있느냐에 따라 공격 방법이 달라지기 때문  
BOF는 프로그램의 undefined behavior(정의되어있지 않은 동작: 런타임 중에 어떤 현상이 발생할지 예측할 수 없다는 뜻)을 이끌어냄  
BOF는 프로그래머가 버퍼의 길이에 대한 가정을 올바르게 하지 않아 발생한다. 이는 보통 길이제한이 없는 API 함수들을 사용하거나 버퍼의 크기보다 입력받는 데이터의 길이가 더 크게 될 때 자주 일어나는 실수다.

- **Stack BOF**  
지역변수가 할당되는 스택메모리에서 Overflow 발생  
프로그래머가 길이에 대한 검증을 수행하지 못해서 발생한다. 입력받을 때 길이 제한이 없는 함수를 사용하면 이 공격에 취약해진다. 입력받은 데이터가 버퍼에 저장되기까지의 흐름을 따라가 버퍼에 크리를 넘는 양을 저장할 수 있는지 가능성을 검토해야한다.  

<--A--><--B-->  
ㅁㅁㅁㅁㅁㅁㅁㅁ  
만약 데이터영역 B에 나중에 호출될 함수포인터를 저장하고 있다면, 이 값을 "AAAAAAAA"와 같은 데이터로 덮었을 때 Segmentation Fault(접근권한이 없는 메모리 영역을 읽거나 쓰려고할 때 발생하는 예외)를 발생시킬 것입니다.  
공격자는 어딘가에 기계어 코드를 삽입한 후 함수포인터를 공격자의 코드의 주소로 덮어 코드 실행 가능  

```
[예제문제 풀면서 배운것]

sfp: saved frame pointer  
이전 함수의 EBP 주소를 저장하고 있는 공간  

sprintf(배열, 서식, 값 1, ...) : 배열에 서식 저장  
ex. sprintf(buf, "Your Input is : %\n", buf);  
만약 buf에 31바이트를 꽉 채운다면 "Your Input is:" 문자열이 앞에 붙어 총 길이가 32바이트를 넘게 됩니다.  
```

프로그래머가 동적으로 메모리를 관리할 수 있는 힙에서도 발생 가능하다. 힙 영역은 스택 영역과 사용 목적이 다르기 때문에 스택오버플로우와는 다른 방법으로 익스플로잇 해야한다. -> Linux Exploitation&Mitigation 강의에서 다룬다. (+힙은 먼저 선언한게 메모리의 low 주소로 들어간다.)


## Out-of-boundary  
버퍼의 길이를 벗어나는 인덱스에 접근할 때 발생하는 취약점  

```
[예제문제 풀면서 배운것]

high 주소  
|int idx|  
|int buf[10]|  
|int win|  
buf배열에서 음수 인덱스로 win에 접근 가능, win도 int이므로 win은 buf[-1]로 접근 가능  

idx % 10했을 때 buf[10] 접근은 안전할까? NO  
양의 정수를 10으로 나눈 나머지로 가능한 값은 0에서 9까지기 때문에 이는 얼핏보면 안전해보인다.  
But, C언어에서는 피연산자가 음수라면 나머지 연산의 결과도 음수가 될 수 있다. 따라서 이 경우 idx의 값의 범위가 -9 ~ 9이므로 나머지가 음수가 되게 한다면 OOB 발생이 가능하다.  

high 주소  
|int idx|  
|int buf[10]|  
|int dummy[7]|  
|int win| -> buf[-8]로 접근 가능  
C언어에서 int형으로 표현 가능한 정수의 범위는 -pow(2,31) ~ pow(2,31)-1 이다.  
int형은 32비트이기 때문에 총 pow(2,32)개의 수를 표현할 수 있다. int형은 0을 포함하기 때문에 포현할 수 있는 음의 정수의 갯수와 양의 정수의 갯수는 다르다.  
int형에서 -pow(2,31)은 표현 가능하지만 pow(2,31)은 표현 가능하지 않다.  
Therefore, pow(2,31)은 표현 가능한 최대 정수보다 하나 더 크기 때문에 이는 -pow(2,31)과 같은 값이 된다.  
=> idx에 -pow(2,31)을 넣었을 때 절댓값을 구하는 연산을 수행해도 -2**31이 그대로 저장된다. ==> OOB 발생  
이를 근본적으로 막기 위해서는 idx를 int형이 아닌 unsigned int형으로 선언하거나, 인덱스를 입력받은 후에 if(idx < 0 | idx >= 10)과 같은 경계 검사 구문을 추가해야 한다.  
```

## Off-bye-one  
경계 검사에서 하나의 오차가 있을 때 발생한다.  
이는 버퍼의 경계 계산 혹은 반복문의 횟수 계산 시 < 대신 <= 을 쓰거나, 0부터 시작하는 인덱스를 고려하지 못할 때 발생한다.

