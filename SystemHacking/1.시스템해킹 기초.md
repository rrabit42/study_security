# Background  
> 컴퓨터 과학을 배워야 하는 이유  
> 시스템 해킹의 기술은 컴퓨터 과학에 뿌리를 두고 있음  
> 단순히 알려진 기술을 습득 + 바탕이 되는 컴퓨터 과학 이해하기 위해 노력  

## Linux Memory Layout  
컴퓨터는 크게 CPU와 메모리로 구성되어 있음  
CPU는 실행할 명령어와 명령어 처리에 필요한 데이터를 메모리에서 읽고, Instruction Set Architecture(ISA)에 따라 이를 처리, 연산의 결과를 다시 메모리에 적재  
=> CPU의 동작과 메모리 사이에는 밀접한 연관  
=> 공격자가 메모리를 악의적으로 조작할 수 있다면 조작된 메모리 값에 의해 CPU도 잘못된 동작 가능  
=> 메모리 오염(Memory Corruption) 취약점  
=> 시스템 해킹의 많은 공격기법이 이 취약점을 기반으로 함  

## 세그먼트(Segment)  
<img width="624" alt="image" src="https://user-images.githubusercontent.com/46364778/207672744-67d037aa-304c-4280-821f-ca5a5ed6911e.png">  

* 리눅스에서는 프로세스의 메모리를 크게 5개의 세그먼트로 구분함  
> 세그먼트: 적재되는 데이터의 용도별로 메모리 구획을 나눈 것  

운영체제가 메모리를 용도별로 나누면, 각 용도에 맞게 적절한 권한을 부여할 수 있음  
권한: 읽기, 쓰기, 실행  
CPU는 메모리에 대해 권한이 부여된 행위만 할 수 있음  

자세한 이해: 운영체제의 메모리 관리기법 중 하나-segmentation 기법, 인텔 x86-64(x64)와 관련된 하드웨어 설계  

### 코드 세그먼트  
> 실행 가능한 기계 코드 위치, 텍스트 세그먼트(Text Segment)라고도 불림  

* 읽기, 실행 권한 -> 프로그램이 동작하려면 코드를 읽고 실행할 수 있어야 하니까  
* 쓰기 권한 X -> 공격자가 악의적인 코드를 삽입하기 쉬워지므로 현대 운영체제는 이 세그먼트에 쓰기 권한 제거함  

EX)  
```
int main() { return 31337; }
```  
main 함수가 컴파일 되면 554889e5b8697a00005dc3라는 기계 코드로 변환됨, 이 기계 코드가 코드 세그먼트에 위치하게 됨  

### 데이터 세그먼트  
> 컴파일 시점에 값이 정해진(초기화된) 전역 변수 및 전역 상수 위치  

* 읽기 권한 -> CPU가 이 세그먼트의 데이터를 읽을 수 있어야 하므로  
* **데이터 세그먼트**: 쓰기가 가능한 데이터 세그먼트, 전역 변수와 같이 프로그램이 실행되면서 값이 변할 수 있는 데이터들이 위치  
* **rodata 세그먼트(read-only data)**: 쓰기가 불가능한 데이터 세그먼트, 전역으로 선언된 상수가 포함  

EX)
```
int data_num = 31337;                       // data
char data_rwstr[] = "writable_data";        // data
const char data_rostr[] = "readonly_data";  // rodata
char *str_ptr = "readonly";  // str_ptr은 data, 문자열은 rodata
int main() { ... }
```  
* "readonly"라는 문자열은 **상수 문자열** 로 취급되어 rodata에 위치  
* str_ptr 포인터 자체는 전역 변수로서 data에 위치  
* const로 선언된 data_rostr[]은 rodata에 위치  

### BSS 세그먼트  
> Block Started By Symbol Segment  
> 컴파일 시점에 값이 정해지지 않은 전역 변수 위치; 개발자가 선언만하고 초기화하지 않은 전역변수 등  

* 이 세그먼트의 메모리 영역은 **프로그램이 실행될 때, 모두 0으로 값이 초기화** 됨 -> 이런 특성 때문에 C 코드를 작성할 때, 초기화되지 않은 전역 변수 값은 0  
* 읽기, 쓰기 권한  

EX) 
초기화되지 않은 전역 변수 bss_data가 BSS 세그먼트에 위치하게 됨  
```
int bss_data;

int main() {
    printf("%d\n", bss_data);  // 0
    return 0;
}
```

### 스택 세그먼트  
> 프로세스의 스택이 위치  
> 함수의 인자, 지역 변수와 같은 임시 변수들이 실행 중에 여기에 저장됨  

* 스택 프레임(Stack Frame) 단위로 사용됨; 스택 프레임은 함수가 호출될 때 생성되고, 반환될 때 해체됨  
* 프로그램 전체 실행 흐름은 사용자의 입력을 비롯한 여러 요인에 의해 영향 받음 -> 어떤 프로세스가 실행될 때, 이 프로세스가 얼마 만큼의 스택 프레임을 사용하게 될지 미리 계산하는 것은 일반적으로 불가능  
* 그래서, 운영체제는 프로세스를 시작할 때 작은 크기의 스택 세그먼트를 먼저 할당, 부족해질 때마다 이를 확장  
* '아래로 자란다' -> 스택이 확장될 때, 기존 주소보다 낮은 주소로 확장 됨  
* 읽기, 쓰기 권한 -> CPU가 자유롭게 값을 읽고 쓸 수 있어야 함  

### 힙 세그먼트  
> 힙 데이터 위치  
> 스택과 마찬가지로 실행 중에 동적으로 할당될 수 있음  
> 리눅스에서는 스택 세그먼트와 반대 방향으로 자람  

* C 언어; malloc(), calloc() 등을 호출해서 할당 받는 메모리가 이 세그먼트에 위치  
* 일반적으로 읽기, 쓰기 권한  

EX)
```
int main() {
  int *heap_data_ptr = malloc(sizeof(*heap_data_ptr));  // 동적 할당한 힙 영역의 주소를 가리킴
  *heap_data_ptr = 31337;              // 힙 영역에 값을 씀
  printf("%d\n", *heap_data_ptr);  // 힙 영역의 값을 사용함
  return 0;
}
```  
* heap_data_ptr은 지역변수 이므로 스택에 위치  
* malloc으로 할당받은 힙 세그먼트의 주소 가리킴  

#### 힙, 스택 세그먼트가 자라는 방향이 반대인 이유?  
두 세그먼트가 동일한 방향으로 자라며, 연속된 메모리 주소에 각각 할당 된다고 가정할 때,  
기존의 힙 세그먼트를 모두 사용하고 나면, 확장하는 과정에서 스택 세그먼트와 충돌하게 됨  

이를 쉽게 해결하기 위해, 리눅스는 스택을 메모리 끝에 위치 시키고, 힙과 스택을 반대로 자라게 함  
힙과 스택은 메모리를 최대한 자유롭게 사용할 수 있으며, 충돌 문제로부터도 비교적 자유롭게 됨  

---  

## Computer Architecture 개요  
CPU: 컴퓨터 작동에 핵심이 되는 연산 처리  
저장장치: 데이터 저장  
GPU: 그래픽 데이터  
랜카드: 네트워크 통신  
사운드 카드: 소리 데이터 처리  
-> 컴퓨터 구조  

전체적인 컴퓨터 구조 중에서 특히 CPU가 사용하는 명령어와 관련된 설계  
-> 명령어 집합구조(Instruction Set Architecture, ISA)  
가장 널리 사용되는 ISA 중 하나가 인텔의 x86-64  

### 컴퓨터 구조(Computer Architecture)  
컴퓨터가 효율적으로 동작할 수 있도록 하드웨어 및 소프트웨어의 기능을 고안하고, 이들을 구성하는 방법  
컴퓨터 구조 = 컴퓨터 기능 구조에 대한 설계 + 명령어 집합 구조 + 마이크로 아키텍처 + 기타 하드웨어 및 컴퓨팅 방법에 대한 설계 등  
* 컴퓨터 기능 구조에 대한 설계 : 컴퓨터가 연산을 효율적으로 하기 위해 어떤 기능들이 컴퓨터에 필요한지 고민하고, 설계  
ex) 폰 노이만 구조, 하버드 구조, 수정된 하버드 구조  

* CPU의 명령어에 대한 설계 = 명령어 집합 구조(Instruction Set Architecture) : CPU가 처리해야하는 명령어를 설계하는 분야  
ex) ARM, MIPS, AVR, 인텔의 x86 및 x86-64  

* CPU의 하드웨어적 설계 = 마이크로 아키텍처(Micro Architecture) : 정의된 명령어 집합을 효율적으로 처리할 수 있도록, CPU 회로를 설계하는 분야  
ex) 캐시 설계, 파이프라이닝, 슈퍼 스칼라, 분기 예측, 비순차적 명령어 처리  

* 하드웨어 및 컴퓨팅 방법론  
ex) 직접 메모리 접근  

> 폰 노이만 구조 & x86-64 아키텍처에 대해 알아보자.

### 폰 노이만 구조  
컴퓨터에 연산, 제어, 저장의 세 가지 핵심 기능이 필요하다고 생각  
연산과 제어를 위한 **중앙처리장치(Central Processing Unit, CPU)**, 저장을 위한 **기억장치(memory)**  
장치 간에 데이터나 제어 신호를 교환할 수 있도록 **버스(bus)** 라는 전자 통로 사용  

<img width="612" alt="image" src="https://user-images.githubusercontent.com/46364778/216032425-83156afa-92a1-4228-afd5-430cee01d07f.png">  

#### 중앙처리장치  
CPU는 프로그램의 연산을 처리하고 시스템을 관리하는 컴퓨터의 두뇌  
프로세스의 코드 불러오고, 실행하고, 결과를 저장하는 일련의 모든 과정이 CPU에서 일어남  
CPU = 산술논리장치(Arithmetic Logic Unit, ALU; 산술/논리 연산 처리) + 제어 장치(Control Unit; 제어 장치) + 레지스터(Register; CPU에 필요한 데이터 저장)  

#### 기억 장치  
컴퓨터가 동작하는데 필요한 여러 데이터를 저장하기 위해 사용  
용도에 따라 주기억장치/보조기억장치로 분류  

주기억장치: 프로그램 실행 과정에서 필요한 데이터들을 임시로 저장하기 위해 사용  
ex) 램(Random-Access Memory, RAM)  

보조기억장치: 운영체제, 프로그램 등과 같은 데이터를 장시간 보관하고자 할 때 사용  
ex) 하드 드라이브(Hard Disk Drive, HDD), SDD(Solid State Drive)  

#### 버스  
컴퓨터 부품과 부품 사이 or 컴퓨터와 컴퓨터 사이에 신호를 전송하는 통로  
ex) 데이터가 이동하는 데이터 버스(Data Bus), 주소 지정하는 (Address Bus), 읽기/쓰기를 제어하는 제어 버스(Control Bus)  
+) 랜선, 데이터 전송 소프트웨어, 프로토콜 등도 버스라고 불림  

> **기억장치가 있는데 CPU 안에 레지스터가 필요한 이유?**  
> CPU는 굉장히 빠른 속도로 연산을 처리, 이를 위해 데이터의 빠른 교환이 필요  
> 필요한 데이터를 빠르게 공급, 반출할 수 있어야 효율 발휘 가능  
> CPU의 연산 속도가 기억장치와의 데이터 교환속도보다 압도적으로 빠르기 때문에 기억장치만을 사용하면 병목현상이 발생  
> 즉, CPU는 교환속도를 획기적으로 단축하기 위해 레지스터와 캐시라는 저장장치를 내부에 갖고 있음  

### 명령어 집합 구조(Instruction Set Architecture, ISA)  
CPU가 해석하는 명령어의 집합  
프로그램은 기계어로 이루어져 있음. 프로그램 실행하면 이 명령어들을 CPU가 읽고 처리  

ISA는 IA-32, x86-64(x64), MIPS, AVR 등 다양하게 존재  
-> 모든 컴퓨터가 동일한 수준의 연산 능력을 요구하지 않음, 컴퓨터 환경도 다양  

ex) x64  
고성능 프로세서를 설계하기 위해 사용, 이를 기반으로 한 CPU들을 많은 전력을 소모, 발열도 상대적으로 심함  
-> 안정적으로 전력 공급, 냉각 장치를 구비하는데 공간상의 부담이 크지 않은  
-> 데스트콥, 랩톱에 적합  
-> 드론(배터리를 사용), 공유기, 인공지능 스피터(크기가 작은 임베디드 기기) -> 이러한 제약조건 해결 어려움  
-> 스마트콘은 피부에 닿아서 발열문제 민감, 배터리로 작동하면 인텔의 고성능 프로세서 장착하기 매우 부적합 -> 임베디드 장비들은 전력 소모와 발열이 적은 ARM이나 MIPS, AVR의 프로세서 사용  

x86기반 CPU의 점유율이 압도적  

### x86-64 아케텍처  
인텔의 64비트 CPU 아키텍처  
인텔의 32비트 CPU 아키텍처인 IA-32를 64비트 환경에서 사용할 수 있도록 확장  
대다수의 개인용 컴퓨터들이 인텔의 x64 CPU 사용하고 있음  

#### n 비트 아키텍처  
CPU가 한번에 처리할 수 있는 데이터의 크기  
= CPU가 이해할 수 있는 데이터의 단위 = WORD  

WORD의 크기는 CPU가 어떻게 설계됐느냐에 따라 달라짐  
ex) 32비트 아키텍처에서 ALU는 32비트까지 계산 가능, 레지스터의 용량 및 각종 버스들의 대역폭이 32비트 -> 이들로 구성된 CPU는 설계상 32비트의 데이터까지만 처리 가능  

#### WORD가 크면 유리한 점  
현대의 PC는 대부분 64비트 아키텍처의 CPU 사용 -> 32비트 아키텍처의 CPU가 제공할 수 있는 가상메모리의 크기가 작음  
**가상메모리**: CPU가 프로세스에게 제공하는 가상의 메모리 공간  
32비트 아키텍처에서는 4,294,967,296 바이트(=4기가 바이트)가 최대로 제공 가능한 가상메모리 크기 => 일상적으로 사용은 적절, 많은 메모리 자원을 소모하는 전문 소프트웨어, 고사양의 게임 등을 실행할 때는 부족  

64비트 아키텍처에서는 16엑사 바이트(=16,777,216 테라바이트)의 가상메모리 제공  
웬만해서는 완전한 사용이 불가능할 정도로 큰 크기  

> x86-64의 여러 이름: Intel64, IA-32e, amd64, EM64T  
> 개발의 역사가 복잡해서  
> x86은 인텔의 것, 64비트로 확장한 기술은 AMD의 것  
> 실제로는 같은 아키텍처  

#### 레지스터  
CPU가 데이터를 빠르게 저장하고 사용할 때 이용하는 보관소  
산술 연산에 필요한 데이터를 저장하거나 주소를 저장하고 참조하는 등 다양한 용도로 사용됨  


### 범용 레지스터(General Register)  
주용도는 있으나 그 외의 다양한 용도로 사용될 수 있는 레지스터  
x86-64에서 각각의 범용 레지스터는 **8바이트** 를 저장할 수 있음, 부호 없는 정수 기준으로 2^64 - 1까지의 수 나타낼 수 있음  

|이름|주용도|  
|:---:|:---:|  
|rax (accumulator register)|함수의 반환 값|  
|rbx (base register)|x64에서는 주된 용도 없음|  
|rcx (counter register)|반복문의 반복 횟수, 각종 연산의 시행 횟수|  
|rdx (data register)|x64에서는 주된 용도 없음|  
|rsi (source index)|데이터를 옮길 때 원본을 가리키는 포인터|  
|rdi (destination index)|데이터를 옮길 때 목적지를 가리키는 포인터|  
|rsp (stack pointer)|사용중인 스택의 위치를 가리키는 포인터|  
|rbp (stack base pointer)|스택의 바닥을 가리키는 포인터|  

+) r8 ~ r15  

### 세그먼트 레지스터(Segment Register)  
x64 아키텍처에는 cs, ss, ds, es, fs, gs 총 6가지 세그먼트 레지스터 존재  
각 레지스터의 크기는 16비트  
세그먼트 레지스터는 x64로 아키텍처가 확장되면서 용도에 큰 변화가 생김  
과거: 메모리 세그멘테이션, 가용 메모리 공간의 확장 위해 사용  
현재: 주로 메모리 보호를 위해 사용  

과거 IA-32, IA-16에서는 세그먼트 레지스터를 이용하여 사용 가능한 물리 메모리의 크기를 키우려고 함  
ex) IA-16에서는 어떤 주소를 cs:offset 이라고 한다면, 실제로는 cs << 4 + offset의 주소를 사용하여 16비트 범위에서 접근할 수 없는 주소에 접근할 수 있었음  
당시 범용 레지스터의 크기가 작아서 사용 가능한 메모리의 주소 폭이 좁았지만, x64에서는 사용 가능한 주소 영역이 굉장히 넓기 때문에 이런 용도로는 거의 사용 X  

현대의 x64에서 cs, ds, ss 레지스터는 코드 영역, 데이터, 스택 메모리 영역을 가리킬 때 사용  
나머지 레지스터는 운영체제 별로 용도를 결정할 수 있도록 범용적인 용도로 제작된 레지스터  

### 명령어 포인터 레지스터(Instruction Pointer Register, IP)  
프로그램은 일련의 기계어 코드로 이루어져 있음  
이 중에서 CPU가 어느 부분의 코드를 실행할지 가리키는 역할(CPU가 실행해야할 코드를 가리키는 레지스터)  
x64 아키텍처의 명령어 레지스터는 rip  
크기는 8바이트  

### 플래그 레지스터(Flag Register)  
프로세서의 현재 상태를 저장하고 있는 레지스터(CPU의 상태를 저장하는 레지스터)  
x64 아키텍처에서는 RFLAGS 라고 불리는 64비트 크기의 플래그 레지스터 존재  
과거 16비트 플래그 레지스터가 확장된 것  
깃발을 올리고, 내리는 행위로 신호를 전달하듯, 플래그 레지스터는 자신을 구성하는 여러 비트들로 CPU의 현재 상태 표현  

RFLAGS는 64비트이므로 최대 64개의 플래그 사용 가능  
실제로는 오른쪽의 20여개의 비트만 사용  

주로 접하게 될 레지스터  
|플래그|의미|  
|:---:|:---:|  
|CF(Carry Flag)|부호 없는 수의 연산 결과가 비트의 범위를 넘을 경우 설정|  
|ZF(Zero Flag)|연산의 결과가 0일 경우 설정|  
|SF(Sign Flag)|연산의 결과가 음수일 경우 설정|  
|OF(Overflow Flag)|부호 있는 수의 연산 결과가 비트 범위를 넘을 경우 설정|  

ex) a = 3, b = 5  
a - b의 연산결과는 음수, SF가 설정됨  
CPU는 SF를 통해 a가 b보다 작았음을 알 수 있음  

#### 레지스터 호환  
x86-64 아키텍처는 IA-32의 64비트 확장 아키텍처, 호환 가능  
IA-32에서 CPU 레지스터들은 32비트 크기 가짐, 명칭이 각각 eax, ebx, ecx, edx, esi, edi, esp, ebp  
호환성을 위해 이 레지스터들은 x86-64에서도 그대로 사용 가능  

앞서 소개한 rax, rbs, rcs, rdx, rsi, rdi, rsp, rbp가 이들의 확장된 버전  
eax, ebx 등은 확장된 레지스터의 하위 32비트를 가리킴  
ex) eax는 rax의 하위 32비트 의미  

과거 16비트 아키텍처인 IA-16과의 호환을 위해  
ax, bx, cx, dx, si, di, sp, bp는 eax, ebx, ecx, edx, esi, edi, esp, ebp의 하위 16비트 가리킴  

이들 중 몇몇은 다시 상위 8비트, 하위 8비트로 나뉨  

<img width="619" alt="image" src="https://user-images.githubusercontent.com/46364778/216038239-7e292da5-4fb8-4333-8349-f33bec1f6b98.png">  

---  

## Calling Convention  
함수 호출 규약 : 함수의 호출 및 반환에 대한 약속  
함수를 호출할 때는 반환된 이후를 위해  
* 호출자(Caller)의 상태(Stack frame)  
* 반환 주소(Return Address)  
를 저장해야 함  
호출자는 피호출자(Callee)가 요구하는 인자를 전달 + 피호출자의 실행이 종료될 때는 반환 값을 전달받아야 함  

함수 호출 규약을 적용하는 것은 일반적으로 컴파일러의 몫  
프로그래머가 고수준 언어로 코드를 작성하면 컴파일러가 호출 규약에 맞게 코드를 컴파일 함  
프로그래머가 코드에 호출 규약을 명시하지 않으면, 컴파일러는 지원하는 호출 규약 중에서 CPU 아키텍처에 적합한 것 선택  
But, 컴파일러의 도움 없이 어셈블리 코드를 작성 or 어셈블리로 작성된 코드를 읽고자 한다면 함수 호출 규약을 알아야함  

### 함수 호출 규약이란?  
컴파일러는 지원하는 호출 규약 중, CPU 아키텍처에 적합한것 선택  
ex) x86(32bit) 아키텍처: 레지스터를 통해 피호출자의 인자를 전달하기에는 레지스터 수가 적으므로, 스택으로 인자를 전달하는 규약 사용  
ex) x86-64 아키텍처: 레지스터가 많으므로 적은 수의 인자는 레지스터만 사용해서 인자 전달, 인자가 너무 많을 때만 스택 사용  

CPU의 아키텍처가 같아도 컴파일러가 다르면 적용하는 호출 규약이 다를 수 있음  
C언어 컴파일 -> 윈도우: MSVC / 리눅스: gcc  
이 둘은 같은 아키텍처에 대해서도 다른 호출 규약 사용  
x86-64 아키텍처에서 MSVC는 MS x64 호출 규약 적용, gcc는 SYSTEM V호출 규약 적용  

> 다양한 함수 호출 규약  
> x86  
> * cdecl  
> * stdcall  
> * fastcall  
> * thiscall  
> x86-64  
> * System V AMD64 ABI의 Calling Convention  
> * MS ABI의 Calling Convention  

### x86호출 규약: cdecl  
x86 아키텍처는 레지스터 수가 적음 -> 스택을 통해 인자 전달 + 인자 전달 위해 사용한 스택을 호출자(caller)가 정리함  
스택을 통해 인자 전달할 때는, 마지막 인자부터 첫번째 인자까지 거꾸로 스택 push  

> 컴파일의 정확한 의미  
> 컴파일(Compilation)의 정확한 의미: 어떤 언어로 작성된 소스 코드(Source Code)를, 다른 언어의 목적 코드(Object Code)로 번역  
> 소스 코드 -> 어셈블리어 or 소스 코드 -> 기계어 : 모두 컴파일의 범주  
> C언어를 실행 가능한 바이너리로 만드는 과정: 전처리 -> 컴파일 -> 어셈블 -> 링크  
> 이를 합해서 '컴파일'이라고 부를 수 있는 것도 위와 같은 이유  

```
// Name: cdecl.c
// Compile: gcc -fno-asynchronous-unwind-tables -nostdlib -masm=intel \
//          -fomit-frame-pointer -S cdecl.c -w -m32 -fno-pic -O0
void __attribute__((cdecl)) callee(int a1, int a2){ // cdecl로 호출
}
void caller(){
   callee(1, 2);
}
```  

```
; Name: cdecl.s
	.file	"cdecl.c"
	.intel_syntax noprefix
	.text
	.globl	callee
	.type	callee, @function
callee:
	nop
	ret ; 스택을 정리하지 않고 리턴합니다.
	.size	callee, .-callee
	.globl	caller
	.type	caller, @function
caller:
	push	2 ; 2를 스택에 저장하여 callee의 인자로 전달합니다.
	push	1 ; 1를 스택에 저장하여 callee의 인자로 전달합니다.
	call	callee
	add	esp, 8 ; 스택을 정리합니다. (push를 2번하였기 때문에 8byte만큼 esp가 증가되어 있습니다.)
	nop
	ret
	.size	caller, .-caller
	.ident	"GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0"
	.section	.note.GNU-stack,"",@progbits
```  
* 인자 거꾸로 전달  
* caller가 스택 정리  
* callee는 스택 정리하지 않고 리턴  

### x86-64호출 규약: SYSV  
리눅스는 SYSTEM V(SYSV) Application Binary Interface(ABI)를 기반으로 만들어짐  
SYSV ABI는 ELF 포맷, 링킹 방법, 함수 호출 규약 등의 내용을 담고 있음  
```file /bin/ls``` 명령어를 이용하여 바이너리 정보를 살펴보면, SYSV 문자열이 포함된 것을 확인할 수 있음  

SYSV에서 정의한 함수 호출 규약의 특징  
1. 6개의 인자를 RDI, RSI, RDX, RCX, R8, R9에 순서대로 저장하여 전달. 더 많은 인자를 사용해야할 때는 스택 추가로 이용  
순서대로 들어가는데 스택에는 반대로 들어가므로 R9에 맨 마지막 인자 넣고, RDI는 제일 첫번째 인자 넣고, 이런 식으로 진행됨
2. Caller에서 인자 전달에 사용된 스택 정리  
3. 함수의 반환 값은 RAX로 전달  

* 인자 전달  
gdb로 sysv를 로드한 후 중단점을 설정하여 caller 함수까지 실행해보자  
6개의 인자를 각각의 레지스터에 설정하고 있음 + 7번째 인자인 7을 스택으로 전달하고 있음  

* 반환 주소 저장  
call이 실행되고 스택을 확인해보면, callee 호출 다음 명령어의 주소가 반환주소로 저장되어 있음  

* 스택 프레임 저장  
callee 함수의 도입부(prologue)를 살펴보면, 가장 먼저 push rbp를 통해 호출자의 rbp를 저장하고 있음  
rbp가 스택 프레임의 가장 낮은 주소를 가리키는 포인터이므로, 이를 Stack Frame Pointer(SFP) 라고 부름  
callee에서 반환될 때, SFP를 꺼내어 caller의 스택 프레임으로 돌아갈 수 있음  

* 스택 프레임 할당  
```mov rbp, rsp```로 rbp와 rsp가 같은 주소를 가리키게 함  
바로 다음에 rsp의 값을 빼게 되면, rbp와 rsp의 사이 공간을 새로운 스택 프레임으로 할당하는 것  
but, callee 함수는 지역 변수를 사용하지 않으므로 새로운 스택 프레임을 만들지 않음  
> 반환값을 저장하는 용도 외로는 사용하지 않는 지역 변수가 있다면, gcc는 이런 변수에 대해 스택을 할당하지 않고 rax를 직접 사용  

* 반환값 전달  
함수의 종결부(epilogue)에 도달하면 반환값을 rax에 옮김  

* 반환  
저장해뒀던 스택 프레임과 반환 주소를 꺼내면서 이뤄짐  
callee 함수가 스택 프레임을 만들지 않았기 때문에 pop rbp로 스택 프레임을 꺼낼 수 있지만, 일반적으로 leave로 스택 프레임을 꺼냄  
스택 프레임을 꺼낸 뒤에는 ret로 호출자 복귀  
앞에서 저장해뒀던 sfp로 rbp가, 반환 주소로 rip가 설정됨  

<img width="649" alt="image" src="https://user-images.githubusercontent.com/46364778/216811452-57547d89-8fa0-40c2-b43a-a8552fd8d731.png">  

---
# 1.해킹의 기초  
### - 해킹이란?  
컴퓨터의 하드웨어나 소프트웨어, 네트워크, 웹사이트 등 각종 정보 체계에서 주어진 권한 이상을 얻거나 의도하지 않은 동작을 일으키는 행위  

### - 해킹의 분류  
시스템해킹: 프로그램의 약점 공격  
그 중에서 우린 소프트웨어 해킹에 대해 공부할 것이다.

### - 해킹의 원리  
만약 프로그래머가 예외처리를 빼먹는다면, 영리한 해커는 프로그램의 규칙을 악용해 자신이 원하는 바를 달성할 수 있을 것.  
프로그램이 잘못된 결과를 내거나, 오류를 발생하는 등의 의도치 않은 동작을 수행하게 되는 문제를 <b>소프트웨어 버그(=소프트웨어 취약점)</b>라 한다.  
1. 프로그래머의 실수  
2. 개발자의 잘못된 가정 -> 항상 올바른 입력이 들어올 것이다. ex) 하트블리드 취약점, 2014, OpenSSL

# 2. 취약점이란?
### - 취약점의 분류  
익스플로잇(악용): 취약점을 이용해 공격자가 의도한 동작을 수행하게 하는 코드 혹은 이를 이용한 공격행위  

```소프트웨어 버그(Bug)``` : 프로그래머가 의도하지 않은 동작을 수행  
```소프트웨어 취약점(Vulnerability)``` : 버그 중 보안에 영향을 미칠 수 있는 버그  
```익스플로잇 가능한 취약점(Exploitable Vulnerability)``` : 소프트웨어 취약점 중 이를 이용해 공격자가 의도한 동작을 수행할 수 있는 버그  
But, 익스플로잇이 가능하다고 해서 익스플로잇을 항상 안정적으로 성공할 수 있는 것은 아니다. 보안 취약점에서 익스플로잇 확률은 위험성을 평가하는 요소 중 하나인데, 이는 익스플로잇 확률이 높을 수록 무기화되어 사용하기 유용하고, 공격이 탐지될 확률이 줄어들기 때문이다.  
```안정적으로 익스플로잇 가능한 취약점(Reliably Exploitable Vulnerability)``` : 익스플로잇이 가능한 취약점 중 매우 높은 확률로 공격에 성공할 수 있는 버그  

### - Attack Vector  
모든 소프트웨어 취약점은 소프트웨어와 공격자가 상호작용하는 곳, 즉 사용자의 입력에서부터 발생. 이를 Attack Vector(공격벡터)라고 한다.  
이러한 Attack Vector들의 집합을 Attack Surface라고 함.  
프로그램의 unreachable 영역에 심각한 보안 취약점이 있다고 가정하자. 만약 해당 코드가 어디에서도 사용되지 않고 공격자가 이를 실행할 방법이 없다면 이는 보안 취약점이라고 할 수 없다.
그러나 이러한 코드들도 잠재적으로 악용될 수 있는 코드이기 때문에 존재해서는 안된다.  
따라서 프로그래머는 사용자에게서 입력받는 부분을 철저히 검증해야함.

### - 취약점의 종류 - 메모리 커럽션 취약점(Memory Corruption)
C/C++와 같이 저수준 언어에서 메모리를 조작해 공격  

* ```Buffer Overflow(BOF)```  
프로그래머가 할당한 크기의 버퍼보다 더 큰 데이터를 입력받아 메모리의 다른 영역까지 오염시킬 수 있는 취약점  

* ```Out-of-Boundary(OOB)```   
버퍼의 길이를 벗어나는 곳의 데이터에 접근할 수 있는 취약점  

* ```Off-by-One```  
경계 검사에서 하나 더 많은 값을 쓸 때 발생하는 취약점  
ex. 32 바이트 크기의 버퍼에 인덱스 32로 접근하는 것 같은 경우.  
이는 반복문을 순회할 때 잘못된 비교연산자를 사용하거나 인덱스가 0부터 시작하는 것을 고려하지 못했을 때 자주 발생  

* ```Format String Bug(FSB)```  
print나 sprintf와 같은 함수에서 포맷스트링 문자열을 올바르게 사용하지 못해 발생하는 취약점. 최신 컴파일러에서는 이를 잘 방어하고 있어 최근에는 잘 발생하지 않는다.  

* ```Double Free/Use-After-Free(UAF)```  
동적할당된 메모리를 정확히 관리하지 못했을 때 발생.  
이미 해제된 메모리를 다시 한번 해제하려고 시도하는 것을 Double Free  
해제된 메모리에 접근해 이를 사용하려고 하는 것은 Use-After-Free

### - 취약점의 종류 - 로지컬 버그(Logical)  
메모리를 조작할 필요없이 공격할 수 있음 -> 익스플로잇 작성이 상대적으로 간단  

* ```Command Injection```  
사용자의 입력을 Shell에 전달해 실행할 때 정확한 검사를 실행하지 않아 발생. 이는 공격자가 원하는 명령을 실행할 수 있는데 비해 익스플로잇이 어렵지 않아 매우 강력한 취약점  

* ```Race condition```  
보안 취약점으로서 Race Condition은 여러 쓰레드나 프로세스의 자원관리를 정확히 수행하지 못해 데이터가 오염되는 취약점. 레이스 컨디션은 발생 원인과 공격기법에 따라 메모리 커럽션 취약점으로도, 로지컬 취약점으로도 분류할 수 있는 취약점  

* ```Path Traversal```  
프로그래머가 가정한 디렉토리를 벗어나 외부에 존재하는 파일에 접근할 수 있는 취약점. 이는 주로 소스코드에서 "../"와 같은 경로 문자를 검사하지 않아 발생  

# 3. 보호기법(Mitigation)  
ex. Stack BOF의 보호기법 중 하나인 Stack Smashing Protector(SSP)는 버퍼 뒤에 랜덤한 값을 넣어두고, 이 값을 특정 시점에 검사하여 버퍼오버플로우가 발생했는지를 탐지.
그리고 만약 공격이 발생했다면 프로그램을 강제로 종료시킴.
이로 인해 공격자는 프로그램에서 버퍼 오버플로우 취약점을 발견해도 공격에 이용하기 어려워짐.  
```공격자```  => || 방패(Mitigation의 역할) ||    취약점을 포함한 프로그램  
