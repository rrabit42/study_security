# Background  

## Linux Memory Layout  
컴퓨터는 크게 CPU와 메모리로 구성되어 있음  
CPU는 실행할 명령어와 명령어 처리에 필요한 데이터를 메모리에서 읽고, Instruction Set Architecture(ISA)에 따라 이를 처리, 연산의 결과를 다시 메모리에 적재  
=> CPU의 동작과 메모리 사이에는 밀접한 연관  
=> 공격자가 메모리를 악의적으로 조작할 수 있다면 조작된 메모리 값에 의해 CPU도 잘못된 동작 가능  
=> 메모리 오염(Memory Corruption) 취약점  
=> 시스템 해킹의 많은 공격기법이 이 취약점을 기반으로 함  

## 세그먼트(Segment)  
<img width="624" alt="image" src="https://user-images.githubusercontent.com/46364778/207672744-67d037aa-304c-4280-821f-ca5a5ed6911e.png">  

* 리눅스에서는 프로세스의 메모리를 크게 5개의 세그먼트로 구분함  
> 세그먼트: 적재되는 데이터의 용도별로 메모리 구획을 나눈 것  

운영체제가 메모리를 용도별로 나누면, 각 용도에 맞게 적절한 권한을 부여할 수 있음  
권한: 읽기, 쓰기, 실행  
CPU는 메모리에 대해 권한이 부여된 행위만 할 수 있음  

자세한 이해: 운영체제의 메모리 관리기법 중 하나-segmentation 기법, 인텔 x86-64(x64)와 관련된 하드웨어 설계  

### 코드 세그먼트  
> 실행 가능한 기계 코드 위치, 텍스트 세그먼트(Text Segment)라고도 불림  

* 읽기, 실행 권한 -> 프로그램이 동작하려면 코드를 읽고 실행할 수 있어야 하니까  
* 쓰기 권한 X -> 공격자가 악의적인 코드를 삽입하기 쉬워지므로 현대 운영체제는 이 세그먼트에 쓰기 권한 제거함  

EX)  
```
int main() { return 31337; }
```  
main 함수가 컴파일 되면 554889e5b8697a00005dc3라는 기계 코드로 변환됨, 이 기계 코드가 코드 세그먼트에 위치하게 됨  

### 데이터 세그먼트  
> 컴파일 시점에 값이 정해진(초기화된) 전역 변수 및 전역 상수 위치  

* 읽기 권한 -> CPU가 이 세그먼트의 데이터를 읽을 수 있어야 하므로  
* **데이터 세그먼트**: 쓰기가 가능한 데이터 세그먼트, 전역 변수와 같이 프로그램이 실행되면서 값이 변할 수 있는 데이터들이 위치  
* **rodata 세그먼트(read-only data)**: 쓰기가 불가능한 데이터 세그먼트, 전역으로 선언된 상수가 포함  

EX)
```
int data_num = 31337;                       // data
char data_rwstr[] = "writable_data";        // data
const char data_rostr[] = "readonly_data";  // rodata
char *str_ptr = "readonly";  // str_ptr은 data, 문자열은 rodata
int main() { ... }
```  
* "readonly"라는 문자열은 **상수 문자열** 로 취급되어 rodata에 위치  
* str_ptr 포인터 자체는 전역 변수로서 data에 위치  
* const로 선언된 data_rostr[]은 rodata에 위치  

### BSS 세그먼트  
> Block Started By Symbol Segment  
> 컴파일 시점에 값이 정해지지 않은 전역 변수 위치; 개발자가 선언만하고 초기화하지 않은 전역변수 등  

* 이 세그먼트의 메모리 영역은 **프로그램이 실행될 때, 모두 0으로 값이 초기화** 됨 -> 이런 특성 때문에 C 코드를 작성할 때, 초기화되지 않은 전역 변수 값은 0  
* 읽기, 쓰기 권한  

EX) 
초기화되지 않은 전역 변수 bss_data가 BSS 세그먼트에 위치하게 됨  
```
int bss_data;

int main() {
    printf("%d\n", bss_data);  // 0
    return 0;
}
```

### 스택 세그먼트  
> 프로세스의 스택이 위치  
> 함수의 인자, 지역 변수와 같은 임시 변수들이 실행 중에 여기에 저장됨  

* 스택 프레임(Stack Frame) 단위로 사용됨; 스택 프레임은 함수가 호출될 때 생성되고, 반환될 때 해체됨  
* 프로그램 전체 실행 흐름은 사용자의 입력을 비롯한 여러 요인에 의해 영향 받음 -> 어떤 프로세스가 실행될 때, 이 프로세스가 얼마 만큼의 스택 프레임을 사용하게 될지 미리 계산하는 것은 일반적으로 불가능  
* 그래서, 운영체제는 프로세스를 시작할 때 작은 크기의 스택 세그먼트를 먼저 할당, 부족해질 때마다 이를 확장  
* '아래로 자란다' -> 스택이 확장될 때, 기존 주소보다 낮은 주소로 확장 됨  
* 읽기, 쓰기 권한 -> CPU가 자유롭게 값을 읽고 쓸 수 있어야 함  

### 힙 세그먼트  
> 힙 데이터 위치  
> 스택과 마찬가지로 실행 중에 동적으로 할당될 수 있음  
> 리눅스에서는 스택 세그먼트와 반대 방향으로 자람  

* C 언어; malloc(), calloc() 등을 호출해서 할당 받는 메모리가 이 세그먼트에 위치  
* 일반적으로 읽기, 쓰기 권한  

EX)
```
int main() {
  int *heap_data_ptr = malloc(sizeof(*heap_data_ptr));  // 동적 할당한 힙 영역의 주소를 가리킴
  *heap_data_ptr = 31337;              // 힙 영역에 값을 씀
  printf("%d\n", *heap_data_ptr);  // 힙 영역의 값을 사용함
  return 0;
}
```  
* heap_data_ptr은 지역변수 이므로 스택에 위치  
* malloc으로 할당받은 힙 세그먼트의 주소 가리킴  

#### 힙, 스택 세그먼트가 자라는 방향이 반대인 이유?  
두 세그먼트가 동일한 방향으로 자라며, 연속된 메모리 주소에 각각 할당 된다고 가정할 때,  
기존의 힙 세그먼트를 모두 사용하고 나면, 확장하는 과정에서 스택 세그먼트와 충돌하게 됨  

이를 쉽게 해결하기 위해, 리눅스는 스택을 메모리 끝에 위치 시키고, 힙과 스택을 반대로 자라게 함  
힙과 스택은 메모리를 최대한 자유롭게 사용할 수 있으며, 충돌 문제로부터도 비교적 자유롭게 됨  

---  

## Computer Architecture 개요  
CPU: 컴퓨터 작동에 핵심이 되는 연산 처리  
저장장치: 데이터 저장  
GPU: 그래픽 데이터  
랜카드: 네트워크 통신  
사운드 카드: 소리 데이터 처리  
-> 컴퓨터 구조  

전체적인 컴퓨터 구조 중에서 특히 CPU가 사용하는 명령어와 관련된 설계  
-> 명령어 집합구조(Instruction Set Architecture, ISA)  
가장 널리 사용되는 ISA 중 하나가 인텔의 x86-64  

### 컴퓨터 구조(Computer Architecture)  
컴퓨터가 효율적으로 동작할 수 있도록 하드웨어 및 소프트웨어의 기능을 고안하고, 이들을 구성하는 방법  


### 명령어 집합 구조(Instruction Set Architecture, ISA)  

### 범용 레지스터(General Register)  

### 세그먼트 레지스터(Segment Register)  

### 플래그 레지스터(Flag Register)  

### 명령어 포인터 레지스터(Instruction Pointer Register, IP)  


---  

# 1.해킹의 기초  
### - 해킹이란?  
컴퓨터의 하드웨어나 소프트웨어, 네트워크, 웹사이트 등 각종 정보 체계에서 주어진 권한 이상을 얻거나 의도하지 않은 동작을 일으키는 행위  

### - 해킹의 분류  
시스템해킹: 프로그램의 약점 공격  
그 중에서 우린 소프트웨어 해킹에 대해 공부할 것이다.

### - 해킹의 원리  
만약 프로그래머가 예외처리를 빼먹는다면, 영리한 해커는 프로그램의 규칙을 악용해 자신이 원하는 바를 달성할 수 있을 것.  
프로그램이 잘못된 결과를 내거나, 오류를 발생하는 등의 의도치 않은 동작을 수행하게 되는 문제를 <b>소프트웨어 버그(=소프트웨어 취약점)</b>라 한다.  
1. 프로그래머의 실수  
2. 개발자의 잘못된 가정 -> 항상 올바른 입력이 들어올 것이다. ex) 하트블리드 취약점, 2014, OpenSSL

# 2. 취약점이란?
### - 취약점의 분류  
익스플로잇(악용): 취약점을 이용해 공격자가 의도한 동작을 수행하게 하는 코드 혹은 이를 이용한 공격행위  

```소프트웨어 버그(Bug)``` : 프로그래머가 의도하지 않은 동작을 수행  
```소프트웨어 취약점(Vulnerability)``` : 버그 중 보안에 영향을 미칠 수 있는 버그  
```익스플로잇 가능한 취약점(Exploitable Vulnerability)``` : 소프트웨어 취약점 중 이를 이용해 공격자가 의도한 동작을 수행할 수 있는 버그  
But, 익스플로잇이 가능하다고 해서 익스플로잇을 항상 안정적으로 성공할 수 있는 것은 아니다. 보안 취약점에서 익스플로잇 확률은 위험성을 평가하는 요소 중 하나인데, 이는 익스플로잇 확률이 높을 수록 무기화되어 사용하기 유용하고, 공격이 탐지될 확률이 줄어들기 때문이다.  
```안정적으로 익스플로잇 가능한 취약점(Reliably Exploitable Vulnerability)``` : 익스플로잇이 가능한 취약점 중 매우 높은 확률로 공격에 성공할 수 있는 버그  

### - Attack Vector  
모든 소프트웨어 취약점은 소프트웨어와 공격자가 상호작용하는 곳, 즉 사용자의 입력에서부터 발생. 이를 Attack Vector(공격벡터)라고 한다.  
이러한 Attack Vector들의 집합을 Attack Surface라고 함.  
프로그램의 unreachable 영역에 심각한 보안 취약점이 있다고 가정하자. 만약 해당 코드가 어디에서도 사용되지 않고 공격자가 이를 실행할 방법이 없다면 이는 보안 취약점이라고 할 수 없다.
그러나 이러한 코드들도 잠재적으로 악용될 수 있는 코드이기 때문에 존재해서는 안된다.  
따라서 프로그래머는 사용자에게서 입력받는 부분을 철저히 검증해야함.

### - 취약점의 종류 - 메모리 커럽션 취약점(Memory Corruption)
C/C++와 같이 저수준 언어에서 메모리를 조작해 공격  

* ```Buffer Overflow(BOF)```  
프로그래머가 할당한 크기의 버퍼보다 더 큰 데이터를 입력받아 메모리의 다른 영역까지 오염시킬 수 있는 취약점  

* ```Out-of-Boundary(OOB)```   
버퍼의 길이를 벗어나는 곳의 데이터에 접근할 수 있는 취약점  

* ```Off-by-One```  
경계 검사에서 하나 더 많은 값을 쓸 때 발생하는 취약점  
ex. 32 바이트 크기의 버퍼에 인덱스 32로 접근하는 것 같은 경우.  
이는 반복문을 순회할 때 잘못된 비교연산자를 사용하거나 인덱스가 0부터 시작하는 것을 고려하지 못했을 때 자주 발생  

* ```Format String Bug(FSB)```  
print나 sprintf와 같은 함수에서 포맷스트링 문자열을 올바르게 사용하지 못해 발생하는 취약점. 최신 컴파일러에서는 이를 잘 방어하고 있어 최근에는 잘 발생하지 않는다.  

* ```Double Free/Use-After-Free(UAF)```  
동적할당된 메모리를 정확히 관리하지 못했을 때 발생.  
이미 해제된 메모리를 다시 한번 해제하려고 시도하는 것을 Double Free  
해제된 메모리에 접근해 이를 사용하려고 하는 것은 Use-After-Free

### - 취약점의 종류 - 로지컬 버그(Logical)  
메모리를 조작할 필요없이 공격할 수 있음 -> 익스플로잇 작성이 상대적으로 간단  

* ```Command Injection```  
사용자의 입력을 Shell에 전달해 실행할 때 정확한 검사를 실행하지 않아 발생. 이는 공격자가 원하는 명령을 실행할 수 있는데 비해 익스플로잇이 어렵지 않아 매우 강력한 취약점  

* ```Race condition```  
보안 취약점으로서 Race Condition은 여러 쓰레드나 프로세스의 자원관리를 정확히 수행하지 못해 데이터가 오염되는 취약점. 레이스 컨디션은 발생 원인과 공격기법에 따라 메모리 커럽션 취약점으로도, 로지컬 취약점으로도 분류할 수 있는 취약점  

* ```Path Traversal```  
프로그래머가 가정한 디렉토리를 벗어나 외부에 존재하는 파일에 접근할 수 있는 취약점. 이는 주로 소스코드에서 "../"와 같은 경로 문자를 검사하지 않아 발생  

# 3. 보호기법(Mitigation)  
ex. Stack BOF의 보호기법 중 하나인 Stack Smashing Protector(SSP)는 버퍼 뒤에 랜덤한 값을 넣어두고, 이 값을 특정 시점에 검사하여 버퍼오버플로우가 발생했는지를 탐지.
그리고 만약 공격이 발생했다면 프로그램을 강제로 종료시킴.
이로 인해 공격자는 프로그램에서 버퍼 오버플로우 취약점을 발견해도 공격에 이용하기 어려워짐.  
```공격자```  => || 방패(Mitigation의 역할) ||    취약점을 포함한 프로그램  
