# 웹 해킹 개요  
웹 해킹은 해킹의 의미처럼 본래의 의도와는 다른 동작을 일으키도록 하거나, 주어진 권한 이상으로 정보를 열람, 복제, 변경 가능한 행위가 웹에서 발생하는 것.  

기업의 업무, 금융, 쇼핑 등 다양한 분야가 웹으로 서비스되면서 제공하는 서비스의 복잡도와 다양성이 증가.  
그로 인해 서버와 어플리케이션에서 처리하는 사용자의 입력 역시 다양해졌고 기능을 구현하면서 높아진 복잡도로 인해  
개발 당시에는 의도치 않았던 동작을 일으킬 수 있는 웹 해킹의 위협도 증가.  

많은 기업들이 자산을 보호하기 위해 많은 서비스와 네트워크 망을 내부망에서 사용하지만, 기업의 대표 사이트 또는 제품(서비스) 등과 같이 웹을 통해 서비스를 운영하는 경우가 많음.  
이런 웹 서비스들은 내부망과 연결되어 있을 가능성이 높아 공격자들이 내부망 침투를 위해 가장 먼저 웹을 공격하기도 함.  

## 웹 해킹 공격 벡터  
<img width="470" alt="4" src="https://user-images.githubusercontent.com/46364778/93002223-6f429c00-f570-11ea-903e-541668ed6325.PNG">  

드림핵 웹사이트 접속 시 발생하는 과정 간략히 표현  
* Client-side : 사용자의 입력을 받고 웹사이트와 통신  
* Server-side : 사용자의 요청 처리  

웹 해킹을 할 때에도 Client-side, Server-side로 공격 대상을 나누어볼 수 있다.  
공격 대상에 따라 공격하는 방식, 형태가 달라지며 공격을 통해 가능한 행위가 달라짐.  

### Client-side Attack  
서비스 사용자에 대한 공격  

웹을 이용하는 사용자는 웹브라우저를 통해 서비스 제공 받는데  
**웹 서버가 제공해주는 데이터**가 공격자에 의해 변조되었을 경우  
**웹 브라우저에서 렌더되는 과정**에서 취약점이 발생하는 경우가 대표적인 공격 형태  
> ex) 게시판 서비스 - 사용자의 입력을 특별한 검증 없이 출력하게 되면 사용자의 입력도 html처럼 취급되고 스크립트도 삽입 가능  
이를 악용하여 공격자는 다른 사용자의 웹 브라우저에 원하는 행위 수행 가능  

### Server-side Attack  
서비스를 운용하는 서버에 대한 공격  

다양한 공격 형태 존재, 공격자가 공격에 성공하게 되면 서버의 어플리케이션 코드 또는 다른 사용자의 정보 유출, 서버 탈취 등의 공격으로 발전될 수 있다.  
운영되는 서비스의 구조와 특징에 따라 위협의 형태가 달라짐.  
> 서비스의 형태에 따라 가지게 되는 특별한 공격 방법이 존재.  
ex) 송금 기능을 지원하는 서비스에서 자신이 가진 금액보다 더 큰 금액으로 요청하게 될 때 특별한 검증 절차 없이 정상적으로 진행된다며, 공격자는 금전적 이득 취득 가능  


## Client: 세션 하이재킹(Session Hijacking)  
쿠키에는 세션 정보가 저장되어 있고 서버는 이를 통해 이용자를 식별하고 인증을 처리함.  
공격자가 이용자의 쿠키를 훔칠 수 있으면 세션에 해당하는 이용자의 인증 상태를 훔칠 수 있는데, 이를 세션 하이재킹이라고 한다.  

드림핵 로그인 기능을 통해 세션을 알아보자.  
> 1. 드림핵 로그인 페이지에서 우클릭 후 검사를 클릭하고 Network 탭을 누릅니다.  
> Preserve log를 체크하고 로그인을 하면 로그인 성공 시 응답을 볼 수 있습니다.  
> 응답을 살펴보면, 서버에서 set-cookie 헤더를 통해 브라우저의 쿠키에 세션 정보를 저장하는 것을 볼 수 있습니다.  
> 2. 크롬 검사에서 Application을 누르고 Cookies 목록 안의 https://dreamhack.io 를 누르면 서버의 set-cookie 헤더를 통해 설정된 쿠키를 확인할 수 있습니다.  
> 3. sessionid 헤더의 값을 메모장에 복사합니다.  
> 이후 사진과 같이 sessionid 헤더의 값을 우클릭한 후 Delete를 클릭하면 브라우저의 쿠키에 저장된 세션 값이 삭제됩니다.  
> 세션 값을 삭제하고 드림핵 페이지를 새로고침하면 로그인이 풀려있는 것을 확인할 수 있습니다.
> 4. 쿠키의 빈 칸을 더블 클릭해 sessionid 헤더를 추가하고, 이전에 복사한 세션 값을 입력하면 브라우저의 쿠키에 세션 값이 설정됩니다.  
> 세션 값을 설정하고 드림핵 페이지를 새로고침하면 로그인이 되는 것을 확인할 수 있습니다.  

## Client: Same Origin Policy  
쿠키, 세션 하이재킹을 방지하기 위해 동일 출처 정책, Same Origin Policy(SOP) 보안 매커니즘이 탄생.  
SOP는 클라이언트 사이드 웹 보안에 있어 중요한 요소.  
실제로 클라이언트 사이드 공격은 이 SOP를 우회하기 위한 것이라고 해도 과언이 아님.  
> 브라우저는 인증 정보로 사용될 수 있는 쿠키를 브라우저 내부에 저장.  
> 이용자가 웹 서비스에 접속할 때, 브라우저는 해당 웹 서비스에서 사용하는 인증 정보인 쿠키를 HTTP 정보에 포함시켜 전달.  
> 뿐만 아니라, 브라우저는 웹 리소스를 통해 간접적으로 타 사이트에 접근할 때도 인증 정보인 쿠키를 함께 전송하는 특징을 가지고 있음.  

클라이언트 입장에서는 가져온 데이터를 악의적인 페이지에서 읽을 수 없도록 해야함. 이것이 바로 SOP.  

### ORIGIN 구분 방법  
ORIGIN은 프로토콜(Protocol Scheme), 포트(Port), 호스트(Host)로 구성. 구성요소가 모두 일치해야 동일한 오리진이라고 함.  
ex) https://same-origin.com/  
|URL|결과|이유|  
|:----:|:---:|:---:|  
|https://same-origin.com/frame.html|Same Origin|Path만 다름|  
|http://same-origin.com/frame.html|Cross Origin|Scheme이 다름|  
|https://cross.same-origin.com/frame.html|Cross Origin|Host가 다름|  
|https://same-origin.com:1234/|Cross Origin|Port가 다름|  

SOP는 Cross Origin이 아닌 Same Origin 일 때만 정보를 읽을 수 있도록 해줌.  
외부 출처에서 불러온 데이터를 읽으려고 할 때는 오류가 발생.  
하지만 읽는 것 외에 데이터를 쓰는 것은 문제 없이 작동.  

### Cross Origin Resource SHaring(CORS)  
브라우저가 SOP에 구애 받지 않고 외부 출처에 대한 접근을 허용해주는 경우가 존재.  
ex) 이미지, 자바스크립트, CSS 등 리소스를 불러오는 \<img\>, \<style\>, \<script\> 등의 태그  
그리고 웹 서비스에서 동일 출처 정책인 SOP를 완화하여 다른 출처의 데이터를 처리해야하는 경우도 있음.  

위 같은 상황에서 자원을 공유하기 위해 사용할 수 있는 공유 방법을 교차 출처 리소스 공유(CORS)라고 함.  
CORS 방법은 관련된 HTTP 헤더를 추가하여 전송하는 방법. 이 외에도 JSON with Padding(JSONP) 방법을 통해 CORS를 대체할 수 있음.  

* HTTP 헤더에 기반  
발신 측에서 CROS 헤더를 설정해 요청하면, 수신 측에서 헤더를 구분해 정해진 규칙에 맞게 데이터를 가져갈 수 있도록 설정.  
> 발신 측에서 POST 방식으로 HTTP를 보냈으나, OPTIONS 메소드를 가진 HTTP 요청이 전달됨.  
> 이를 **CORS preflight**: 수신 측에 웹 리소스를 요청해도 되는지 질의하는 과정  

|Header|설명|  
|:---:|:---:|  
|Access-Control-Allow-Origin|헤더 값에 해당하는 Origin에서 들어오는 요청만 처리합니다.|  
|Access-Control-Allow-Methods|헤더 값에 해당하는 메소드의 요청만 처리합니다.|  
|Access-Control-Allow-Credentials|쿠키 사용 여부를 판단합니다. 예시의 경우 쿠키의 사용을 허용합니다.|  
|Access-Control-Allow-Headers|헤더 값에 해당하는 헤더의 사용 가능 여부를 나타냅니다.|  

> 브라우저는 수신측의 응답이 발신측의 요청과 상응하는지 확인하고, 그때야 비로소 POST 요청을 보내 수신측의 웹 리소스를 요청하는 HTTP 요청을 보냅니다.  

* JSONP  
이미지나 자바스크립트, CSS 등의 리소스는 SOP에 구애 받지 않고 외부 출처에 대해 접근을 허용.  
JSONP 방식은 이러한 특징을 이용해 \<script\> 태그로 Cross Origin의 데이터를 불러온다.  
하지만 \<script\> 태그 내에서는 데이터를 자바스크립트의 코드로 인식하기 때문에 Callback 함수를 활용해야 함!  
Cross Origin에 요청할 때 callback 파라미터에 어떤 함수로 받아오는 데이터를 핸들링할지 넘겨주면, 대상 서버는 전달된 Callback으로 데이터를 감싸 응답.  

> 웹 리소스 요청 코드  
```
<script>
/* myCallback이라는 콜백 함수를 지정합니다. */
function myCallback(data){
    /* 전달받은 인자에서 id를 콘솔에 출력합니다.*/
	console.log(data.id)
}
</script>
<!--
https://theori.io의 스크립트를 로드하는 HTML 코드입니다.
단, callback이라는 이름의 파라미터를 myCallback으로 지정함으로써
수신측에게 myCallback 함수를 사용해 수신받겠다고 알립니다.
-->
<script src='http://theori.io/whoami?callback=myCallback'></script>
```

> 웹 리소스 요청에 따른 응답 코드  
```
/*
수신측은 myCallback 이라는 함수를 통해 요청측에 데이터를 전달합니다.
전달할 데이터는 현재 theori.io에서 클라이언트가 사용 중인 계정 정보인
{'id': 'dreamhack'} 입니다. 
*/
myCallback({'id':'dreamhack'});
```

예시 코드 동작을 함께 살펴보자.  
13 번째 줄에서 Cross Origin의 데이터를 불러온다.  
이 때 callback 파라미터로 myCallback을 함께 전달한다.  
Cross Origin에서는 응답할 데이터를 myCallback 함수의 인자로 전달될 수 있도록 myCallback으로 감싸 Javascript 코드를 반환해준다.  
반환된 코드는 요청측에서 실행되기 때문에 3~6번 줄에서 정의된 myCallback 함수가 전달된 데이터를 읽을 수 있음.  

다만 JSONP는 CORS가 생기기 전에 사용하던 방법으로 현재는 거의 사용하지 않는 추세, 새롭게 코드를 작성할 때에는 CORS를 사용해야 함.  

## Client: Cross Site Scripting(XSS)  
공격자가 웹 리소스에 악성 스크립트를 삽입해 이용자의 웹 브라우저에서 해당 스크립트를 실행하도록 함.  
해당 취약점을 통해 특정 계정의 세션 정보 탈취, 해당 계정으로 임의의 기능 수행 가능.  
> 해당 페이지에 접속하면 오리진 사이트가 명령한 것으로 해석하고 악성 스크립트 실행  

### XSS 발생 예시와 종류  
XSS 공격은 이용자가 삽입한 내용을 출력하는 기능에서 발생  
ex) 로그인 시 출력되는 "안녕하세요 00회원님" 같은 문구, 게시글, 댓글  

클라이언트는 HTTP 형식으로 웹 서버에 리소스를 요청하고 서버로부터 받은 응답, 즉 HTML, CSS, JS 등의 웹 리소스를 시각화하여 이용자에게 보여줌.  
이때, HTML, CSS, JS와 같은 코드가 포함된 게시물을 조회할 경우 이용자는 변조된 페이지를 보거나 스크립트가 실행될 수 있음.  

XSS는 발생 형태에 따라서 다양한 종류로 구분  

|종류|설명|  
|:---:|:---:|  
|Stored XSS|XSS에 사용되는 악성 스크립트가 서버에 저장되고 서버의 응답에 담겨오는 XSS|  
|Reflected XSS|XSS에 사용되는 악성 스크립트가 URL에 삽입되고 서버의 응답에 담겨오는 XSS|  
|DOM-based XSS|XSS에 사용되는 악성 스크립트가 URL Fragment에 삽입되는 XSS. (Fragment는 서버 요청/응답 에 포함되지 않습니다.)|  
|Universal XSS|클라이언트의 브라우저 혹은 브라우저의 플러그인에서 발생하는 취약점으로 SOP 정책을 우회하는 XSS|  

