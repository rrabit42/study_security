Webhacking 공부하면서 웹 기초지식에 URI가 나오는데,
개발할 때 공부했기도 하고 정확하게 정리하고 넘어가고 싶어서 정리하고자 한다.  
근데 REST API에 대한 문서가 되어버렸다는게 함정ㅋㅋ  

# API  
프론트엔드 개발자와 백엔드 개발자가 만나는 지점인 API!  
일반적으로 앱이나 웹 상에서 작동하는 어플리케이션을 개발할 때 주로 HTTP나 HTTPS 프로토콜을 사용하여 API를 만들게 되는데,
이 API의 정의가 얼마나 직관적이고 명확하냐에 따라 프로젝트의 복잡도가 크게 낮아지게 될 만큼 시스템 설계에 있어서 꽤나 중요한 차리를 차지하고 있다.  

그래서 우리는 일종의 약속을 통해 이 API가 어떤 동작을 수행하는 API인지를 명확하게 정의해야함.  
이 API 정의 과정에서 우리가 사용할 수 있는 요소들이 바로 **HTTP 메소드**와 **URI(Uniform Resource Identifiers)**이다.  
```GET https://evan.com/users/1```  
HTTP API의 엔드포인트(endpoint)는 위와 같이 HTTP 메소드와 URI를 사용하여 이 API가 어떠한 동작을 수행하는 API인지를 표현하게 된다.  

여기서 중요한 포인트는 사용자가 이 표현을 읽고난 뒤 API에게 기대하는 동작과 실제로 서버가 수행하는 동작이 명확하게 일치되어야 한다는 것이다.  
우리가 서버에게 "앞으로 한걸음 가줘!"라고 요청했는데 서버가 응답으로 "ㅇㅋ뒤로 한걸음 갔음!"이라고 한다면 꽤나 당황스럽지 않겠는가?  

그래서 우리는 REST와 같은 가이드라인을 사용한다.  
하지만 말그대로 가이드라인이기 때문에 지키지 않는다고해서 에러가 발생하거나 하는게 아니지만, 그렇다고 이런 가이드라인을 무시하고 마음대로 개발해도 된다는 것은 아니다.  

# Rest API  
- **Rest(REpresentational State Transfer)**: HTTP 기반으로 필요한 자원에 접근하는 방식을 정해놓은 아키텍쳐.  
- 여기서 **자원**이란? 자원은 저장된 데이터(DBMS)는 물론, 이미지/동영상/문서(pdf 등)와 같은 파일, 서비스(이메일 전송, 푸쉬 메세지 등)를 모두 포함.  


> 번역하면 **표현된 상태**?! 이때 상태라함은 서버가 가지고 있는 리소스의 상태를 이야기한다.  
> 즉, REST는 통신을 통해 자원의 표현된 상태를 주고받는 것에 대한 아키텍처 가이드라인이다.  
> REST에 대한 이야기를 할 때, 많은 분들이 이 표현된 상태(Representational State)에 대한 이해를 어려워하는데, 이는 클라이언트와 서버가 API통신을 통해 주고 받는 것들이 리소스 그 자체라고 생각하기 때문이다.  
> 하지만 조금만 생각해보면 우리가 통신을 통해 리소스를 직접 주고받고 있지 않다는 사실을 알 수 있다.  

> 우리가 API를 통해 주고 받는 리소스는 어떤 문서일수도 있고, 이미지 또는 단순한 JSON데이터일 수 있다.  
> 하지만 사실 우리는 리소스를 직접 주고 받는 것이 아니다.  
> 무슨말인 즉슨, 아래와 같이 클라이언트가 서버에게 특정 유저의 정보를 받아오는 API 엔드포인트를 통해 요청을 보냈다고 가정해보자.  
```
GET https://iamserver.com/api/users/2
Host: iamserver.com
Accept: application/json
```  
> 클라이언트는 이 API 엔드포인트를 사용하여 서버에게 2번 유저의 자원을 요청했고, 서버가 요청을 성공적으로 처리했다면 클라이언트는 서버로부터 대략 이런 느낌의 응답을 받을 수 있다.  
```
HTTP/1.1 200 OK
Content-Length: 45
Content-Type: application/json

{
  id: 2,
  name: 'Evan',
  org: 'Viva Republica',
}
```  
> 자, 서버가 보내준 응답의 바디에는 2번 유저의 데이터가 담겨있다. 일반적으로 우리는 이 상황을 /api/users/2라는 엔드포인트를 통해서 2번 유저 데이터 리소스를 받아왔다고 표현하고는 한다. 사실 필자도 편의상 이런 표현을 자주 사용하고는 한다.  
> 그런데…정말로 지금 서버가 보내준 저 JSON 데이터가 리소스 자체일까? **NO!!**  

> 사실 서버에서 보내준 저 JSON은 리소스 원본이 아니라 데이터베이스에 저장된 2번 유저의 데이터 리소스를 표현한 것에 불과하다. 서버는 클라이언트의 요청을 받고 2번 유저의 정보를 데이터베이스에서 조회한 후 요청의 헤더에 담겨있던 application/json이라는 방식으로 표현하여 응답에 담아준 것이다.  

> 곰곰히 생각해보면 당연한 이야기인 것이, 서버가 접근하는 진짜 리소스 원본은 그저 데이터베이스에 담겨있는 하나의 로우이거나 파일에 작성된 데이터일 것이다. 물론 서버의 로컬 시스템에 리소스를 JSON 파일로 저장하고 있을 수도 있지만 어쨌든 포인트는 서버가 보내준 저 JSON이 원본 리소스가 아니라는 것이다.  

> 서버가 보내준 JSON은 단지 데이터베이스에 저장되어있는 원본 데이터 리소스의 현재 상태를 표현한 것이다.  

> **리소스를 표현한 상태라는 것의 의미**  
> 원본 리소스는 데이터베이스에 저장된 하나의 로우로써 존재하지만 클라이언트에게 이걸 그대로 넘겨줄 수는 없으니 서버가 원본 리소스를 읽어와서 적당한 상태로 표현해주는 것이다.  
> 그리고 이 적당한 상태에 대한 힌트는 HTTP 요청 헤더나 응답 헤더에 전부 나와있다.  
```
GET https://iamserver.com/api/users/2
Host: iamserver.com
Accept: application/json
```  
> 위에서 예시로 들었던 상황에서 클라이언트는 서버에게 2번 유저의 리소스를 요청하며 요청 헤더의 ```Accept```라는 키에 ```application/json```이라는 값을 담아서 보냈다.  
> 클라이언트가 서버에게 “2번 유저의 상태를 json으로 표현해줘”라는 요청을 보낸 것이다.  
> 만약 클라이언트가 ```application/json```이 아닌 ```application/xml```을 담아보냈고, 서버가 XML 포맷의 표현을 지원하도록 작성되어있다면 2번 유저의 리소스는 XML 형태로 표현되어 내려왔을 것이다.  

> 그리고 서버는 응답 헤더에 ```Content-Type```이나 ```Content-Language```와 같은 키를 사용하여 이 리소스가 어떤 방식으로 표현된 상태인지 클라이언트에게 알려주고, 클라이언트 또한 이 정보를 읽은 후 각 컨텐츠 타입에 맞게 정보를 파싱한다.  

> 즉, 클라이언트는 2번 유저의 리소스를 받은 것이 아니다. JSON으로 표현된 2번 유저 리소스의 현재 상태를 받은 것이다. 이처럼 REST는 클라이언트와 서버가 리소스의 타입이나 원하는 언어 등을 사용하여 자원을 자유롭고 명확하게 표현할 수 있는 것에 집중한다.  

앞서 이야기했듯이, REST는 결국 리소스를 어떻게 하면 명확하게 표현할 수 있을지에 대한 것에 집중하는 아키텍처 스타일이다. 하지만 우리가 HTTP API를 사용할 때는 단순히 리소스의 표현 상태만으로는 클라이언트가 API를 호출했을 때 서버에서 정확히 어떤 일이 발생하는지 알기가 어렵다.  

REST는 단지 리소스가 표현된 상태만을 이야기할 뿐, 어떠한 “행위”에 대해서는 이야기하고 있지 않기 때문이다. 하지만 클라이언트가 서버의 API를 사용할 때 원하는 것은 소스를 생성하거나 삭제하거나 수정하는 등 명백히 어떠한 행위이다.  

그래서 RESTful API에서는 REST 아키텍처를 통해 표현된 리소스와 더불어 어떠한 행위를 명시할 수 있는 HTTP 메소드와 URI까지 활용하게 되며, 각 요소들이 표현하고 있는 것들은 다음과 같다.  


1. 리소스가 어떻게 표현되는지? - **REST** ~~(앞에서 얘기함)~~
2. 어떤 리소스인지? - **URI**
3. 어떤 행위인지? - **HTTP 메소드**

즉, 이 요소들을 사용하여 명확하게 정의된 API를 사용하는 클라이언트는 굳이 API에 대한 구구절절한 설명이 없이 GET /users/2와 같은 엔드포인트만 보고도 “음, 2번 유저의 정보를 가져오는 API겠군”이라고 추측할 수 있게 되는 것이다.  

- **Rest API**: REST를 통해 서비스 API를 구현한 것을 말함.  
- REST의 4개의 속성  
**속성1**: 서버에 있는 모든 resource는 각 resource당 클라이언트가 바로 접근할 수 있는 고유 URI가 존재.  
**속성2**: 모든 요청은 클라이언트가 요청할 때마다 필요한 정보를 주기 때문에 서버에서는 세션 정보를 보관할 필요가 없다. 그렇기 때문에 서비스에 자유도가 높아지고 유연한 아키텍쳐 적용이 가능하다.  
**속성3**: HTTP 메소드를 사용한다. 모든 resource는 일반적으로 http 인터페이스인 GET, POST, PUT, DELETE 4개의 메소드로 접근 되어야 한다.  
**속성4**: 서비스 내에 하나의 resource가 주변에 연관된 리소스들과 연결되어 표현이 되어야 한다.  

## REST 구성요소  
### 자원(resource)  
REST에서는 자원에 접근할 때 **URI(Uniform Resource Identifier)**로 하게 된다. URI는 자원의 위치를 나타내는 일종의 식별자.  

<URI 설계시 지켜야 하는 설계 규칙>  
**0. '/'의 쓰임새**  
- 슬래시 구분자(/)는 계층 관계를 나타내는데 사용  
```http://www.happy-zoo/animals/dogs/john```  
해당 사이트에서 'john'의 개 정보를 찾을 때 'happy-zoo'부터 하위 소속들을 거쳐서 'john'까지 도달하는 구조  
- 그렇기 때문에 URI 마지막 문자로 슬래시(/)를 포함하지 않는다.  


**1. URI를 이루는 resource들은 동사보다는 명사로 이루어져야 한다.**  
- 자원의 정보를 표현해야하는 URI는 동사보다는 명사로 구성되어야 한다.  
> #### resource간의 관계를 나타내는 방법  
> REST 리소스 간에는 연관 관계가 있을 수 있고, 이런 경우 다음과 같은 표현방법으로 사용  
```
/리소스명/리소스ID/관계가 있는 다른 리소스명

ex) GET: /users/{userid}/devices (일반적으로 소유 'has'의 관계를 표현할 때)
```  
> 만약 관계명이 복잡하다면 이를 서브 리소스에 명시적으로 표현하는 방법이 있다.  
> 예를 들어, 사용자가 '좋아하는' 디바이스 목록을 표현해야 하는 경우,  
```
GET: /users/{userid}/likes/devices (관계명이 애매하거나 구체적 표현이 필요할 때)
```  


**2. URI에서는 '_'(언더바)보다는 '-'(하이픈)을 권장**  
가독성이 중요한 '_'은 resource 해석에 혼란을 줄 수 있기 때문.  


**3. URI 경로에는 소문자가 적합**  
URI 경로에 대문자 사용은 피하도록한다. 대소문자에 따라 다른 리소스로 인식하게 되기 때문. RFC 3986(URI 문법 형식)은 URI 스키마와 호스트를 제외하고는 대소문자를 구별하도록 규정하기 떄문이다.  

**4. 파일 확장자는 URI에 포함시키지 않는다.**  
```http://restapi.example.com/members/soccer/345/photo.jpg  (x)```  
REST API에서는 메세지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URI안에 포함시키지 않는다.  
Accept header를 사용하도록 해야한다.  
```
GET /members/socceer/345/photo HTTP/1.1 Host:
restapi.example.com Accept: image/jpg
```

### HTTP method  
자원에 접근할 때 어떤 성격의 요청인지 HTTP 메소드가 알려준다.  
그 종류로는 GET, POST, PUT, DELETE가 존재한다.  
![1](https://user-images.githubusercontent.com/46364778/97614157-ef5b8d00-1a5c-11eb-8eb4-a4d8ea80b826.png)  

**Endpoint**   
![2](https://user-images.githubusercontent.com/46364778/97614165-f1255080-1a5c-11eb-9c2e-d1dcbdc46a3c.png)  

메소드는 같은 URI들에 대해서도 다른 요청을 하게끔 구별해주는 항목이 있다. 이것을 Endpoint라고 한다.  
위의 표에서 ```http://api.domain.com/books/1``` URI에 대해 'GET', 'PUT', 'DELETE'메소드에 따라 다른 요청 성격을 띄고 있는 것을 알 수 있다.  

### message  
메세지는 HTTP header와 body, 응답상태코드로 구성되어 있으며, header와 body에 포함된 메세지는 메세지를 처리하기 위한 충분한 정보를 포함한다.  

#### Body  
자원에 대한 정보를 전달(데이터 포맷: JSON/XML/사용자 정의 포맷)  

#### Header  
HTTP 바디에 어떤 포맷으로 데이터가 담겼는지 정의.
요청 HTTP 헤더는 'Accept'항목으로,
응답 HTTP 헤더는 'Content-type'으로 컨텐츠 타입을 설명.

#### 응답상태코드  
status code를 통해 리소스 요청에 대한 응답을 할 수 있다.  
~~알지?~~  

## 장/단점  
### 장점
* 언어와 플랫폼에 독립적
* SOAP(다른 통신방식)보다 개발이 쉽고 단순
* REST가 지원하는 프레임워크나 언어 등 도구들이 없어도 구현이 가능
* 기존 웹 인프라를 사용 가능하다. HTTP를 그대로 사용하기 때문이다.  

### 단점  
* HTTP 프로토콜만 사용이 가능  
* p2p 통신 모델을 가정했기 때문에 둘 이상을 대상으로 하는 분산환경엔 유용하지 않다.
* 보안, 정책등에 대한 표준이 없기 때문에 관리가 어렵고 이러한 부분까지 고려해서 구현 할 경우 설계나 구현에서 좀 더 어려움을 갖는다.

## 활용  
그렇다면 REST가API로써 어떻게 쓰일까요?  
API를 설명 할 때 웹서비스와 특정 기술을 연결해주는 징검다리 역할이라고 말을 했었는데요, REST API도 똑같습니다.  

예를들면 카카오 developer에 있는 카카오 로그인 프로그램을 자신의 웹서비스에 구현하고자 한다면 카카오에서 제공하는 로그인 API를 사용하면 됩니다. 이때 방법으로써 REST가 쓰이는 것이 REST API가 되는 것이죠.  

웹서비스에서 로그인 데이터에 필요한 부분들을 REST 방식(URI형식으로 request)으로 카카오 데이터 베이스에 요청하는 식으로 작동하는 것이죠. 정말 간단하게 구현이 가능해서 REST API는 웹에서 일반적으로 사용되는 API라고 볼 수 있습니다.  

# 출처  
[REST API ?](https://medium.com/@dydrlaks/rest-api-3e424716bab)  
[프론트엔드와 백엔드가 소통하는 엔드포인트, RESTful API](https://evan-moon.github.io/2020/04/07/about-restful-api/)  

+) PUT과 PATCH에 대해  
흔히들 PUT 메소드를 리소스를 수정한다는 개념으로 설명하고는 하지만, 실제 PUT 메소드가 의미하는 것은 리소스를 수정하는 것이 아니라 리소스를 요청 바디에 담긴 것으로 대체하는 것이다.  
즉, 수정할 사항만 보내는 것이 아니라 수정하지 않을 사항까지도 모두 보내야한다는 것이다.  
이렇게 리소스를 대체한다는 PUT 메소드의 특성 상, 실수로 { id: null, name: 'ethan' }과 같은 리소스를 전송해버리기라도 하면 이 유저는 영영 ID를 잃어버린 비운의 유저가 되어버리는 경우도 발생할 수 있다. (사실 이 정도 예외처리는 다들 기본적으로 해놓긴 한다.)  
하지만 그냥 리소스를 받아서 대체하면 된다는 동작 자체가 워낙 심플하기 때문에 리소스를 수정하는 쪽이든 받아서 처리하는 쪽이든 이것저것 신경써줘야 할 일이 별로 없어서 편하기는 하다.  


반면 우리가 PATCH 메소드를 사용하여 방금과 동일한 행위를 하려고 하면 어떨까?  
PUT 메소드와 다르게 PATCH 메소드는 진짜로 현재 저장되어 있는 리소스에 수정을 가하는 행위를 의미하기 때문에 굳이 수정하지 않은 사항을 요청 바디에 담아줄 필요도 없다.  
PATCH메소드는 PUT처럼 수정하지 않을 사항까지 보낼 필요가 없고 진짜 수정하고 싶은 사항만 깔끔하게 보내면 되기 때문에, 쓸데없이 큰 요청 바디를 만들지 않을 수 있다.  

또한 실제로 이러한 수정 동작을 수행하는 API를 사용할 때는 SQL의 UPDATE와 동일한 의미를 떠올리는 경우가 많기 때문에, 리소스를 대체하는 PUT 메소드보다 리소스의 일부를 수정하는 PATCH 메소드가 수정이라는 의미를 가지기에도 더 적합하다고 할 수 있다.  
아직까지는 리소스를 수정하는 행위를 표현할 때 PUT 메소드를 주로 사용하는 경우가 많기는 하지만, PUT 메소드와 PATCH 메소드의 의미적인 차이는 분명히 존재하므로 API의 엔드포인트를 설계할 때 **리소스를 대체**, **리소스를 수정** 중 원하는 행위와 일치하는 메소드를 사용하는 것을 권장한다.  

+) 멱등성 보장  
멱등성이란, 수학이나 전산학에서 어떤 대상에 같은 연산을 여러 번 적용해도 결과가 달라지지 않는 성질을 이야기한다. 즉, 단순히 HTTP 메소드에만 국한된 이야기는 아니고 이는 데이터베이스나 파일에 자원을 읽고 쓰는 등 컴퓨터가 수행하는 모든 연산에 해당되는 이야기이다.  
> 가장 대표적으로 멱등성이 보장되는 연산은 바로 어떠한 수에 1을 곱하는 연산이다. x => x * 1과 같은 함수는 어떠한 값에 1번을 적용하든, 10,000번을 적용하든 항상 x를 반환한다.  
> 그러나 1을 곱하는 것이 아니라 1을 더하거나 빼는 함수라면 한번 호출될 때마다 인자로 주어진 값을 계속 증가시키거나 감소시킬 것이므로 항상 같은 값을 반환하지 않는다. 이러한 성질의 연산이 바로 멱등성을 보장하지 않는 연산의 대표적인 예이다.  

HTTP 메소드 또한 결국 어떠한 자원을 읽고 쓰고 수정하고 지우는 CRUD에 대한 의미를 가지기 때문에, 우리는 어떤 행위가 멱등성을 보장하고 어떤 행위가 멱등성을 보장하는지 알고 있어야 어플리케이션이 예상하지 못한 방향으로 동작하는 것을 방지할 수 있다.  

|Method|멱등성 보장|
|:---:|:---:|
|GET|O|
|PUT|O|
|DELETE|O|
|POST|X|
|PATCH|X|

일단 깊게 생각하지말고 위 테이블을 한번 보자. GET 메소드는 단지 리소스를 읽어 오는 행위를 의미하기에 아무리 여러 번 수행해도 결과가 변경되거나 하지는 않을 것이다. 마찬가지로 요청에 담긴 리소스로 기존 리소스를 그대로 대체해버리는 PUT 메소드 또한 여러 번 수행한다한들 요청에 담긴 리소스가 변하지 않는 이상 연산 결과가 동일할 것이다.  

즉, 어떤 리소스를 읽어오거나 대체하는 연산은 멱등성을 보장한다고 이야기할 수 있다. 그렇다면 멱등성이 보장되지 않는 케이스는 어떤 것이 있을까?  

POST 메소드의 경우 리소스를 새롭게 생성하는 행위를 의미하기 때문에 여러 번 수행하게 되면 매번 새로운 리소스가 생성될 것이고, 그 말인 즉슨 결국 연산을 수행하는 결과가 매번 달라진다는 것을 의미한다. POST 메소드와 같이 멱등성을 보장하지 않는 동작은 한 번 수행될 때마다 어플리케이션의 상황이 전혀 다르게 변화시킬 수도 있다.  

이러한 HTTP 메소드의 멱등성에 대한 지식은 에러에 대한 정보가 별로 없는 상태에서 디버깅을 진행할 때도 활용될 수 있기 때문에 여러모로 알고 있는 편이 좋다고 생각한다. 똑같이 통신 후에 발생하는 에러라고 해도 GET을 여러 번 수행했을 때 발생하는 에러와 POST를 여러 번 수행했을 때 발생하는 에러는 전혀 다른 컨텍스트를 가지고 있을 수 있다는 것이다.  

**PATCH는 왜 멱등성이 보장되지 않는다는 걸까?**  
사실 정확하게 이야기하면 PATCH 메소드는 구현 방법에 따라서 PUT 메소드처럼 멱등성이 보장될 수도 있고, 혹은 보장되지 않을 수도 있다고 할 수 있다.  

PATCH 메소드는 PUT 메소드처럼 리소스를 대체하는 행위가 아니기 때문에 요청을 어떤 방식으로 사용하는지에 대한 제한이 딱히 없기 때문이다. RFC 스펙 상의 PATCH 메소드는 단지 리소스의 일부를 수정한다는 의미만을 가질 뿐이다.

예를 들어, 앞서 필자가 설명했던 예시처럼 PATCH 메소드에 수정할 리소스의 일부분만 담아서 보내는 경우에는 당연히 멱등성이 보장된다.  

이 PATCH 요청은 명확하게 age라는 필드를 31로 수정하는 행위만을 의미하므로 아무리 여러 번 수행한다고 해도 늘 age는 31이라는 값을 가질 것이기 때문이다. 이건 굉장히 일반적인 PATCH 메소드의 구현 방법이고, 실제로 필자도 PATCH 메소드를 사용해야한다면 이렇게 구현한다.  

근데 왜 PATCH 메소드는 멱등성 보장이 안될 수도 있다는 것일까?  

뭐든지 원조가 중요하니 PATCH 메소드를 처음으로 정의해놓은 RFC-5789 문서를 한번 까보도록 하자. 보통 RFC 문서에는 정의된 개념에 대한 설명과 간략한 예시도 포함되어 있는 경우가 많으니, PATCH 메소드의 올바른 구현 방법 또한 적혀있을 것 같다.  

놀랍게도~~어이없게도~~ RFC-5789 문서에 있는 예시 요청의 바디에는 단지 description of changes라는 설명만 적혀있을 뿐, 어떤 제약 조건도 적혀있지 않다. 즉, 별다른 제약없이 개발자 마음대로 API의 인터페이스를 정의해도 된다는 의미이기 때문에 이런 느낌으로 API를 구현하는 것도 가능하다는 것이다.  
```
PATCH users/1
{
  $increase: 'age',
  value: 1,
}
```

이 요청의 $increase 필드의 값은 증가시키고 싶은 속성을 의미하고, value 필드의 값은 그 속성을 얼마나 증가시킬 것인지를 나타내고 있다. 이 경우 API가 호출될 때마다 에반의 나이는 1씩 증가(…😢)할 것이기 때문에 이 API는 멱등성을 보장하지 않는다.  

즉, 자세한 스펙 상 구현 방법에 대한 제약이 없으니 API를 어떻게 구현하느냐에 따라서 PATCH 메소드는 멱등성을 보장할 수도 있고 아닐 수도 있는 것이다.  




